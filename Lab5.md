# Лабораторная работа №5: Работа с файлами

## Цель работы
Реализовать систему загрузки, обработки и хранения файлов с поддержкой streaming, генерацией thumbnails для изображений и интеграцией с основным функционалом приложения.

---

## Задание 1. Система загрузки файлов

### Модель FileMetadata
Создайте таблицу для метаданных файлов:
- `Id` — Guid
- `FileName` — string, имя файла в хранилище
- `OriginalFileName` — string, оригинальное имя
- `ContentType` — string, MIME type
- `Size` — long, размер в байтах
- `UploadedBy` — Guid, FK к User
- `UploadedAt` — DateTime
- `Path` — string, относительный путь
- `Hash` — string, SHA256 хеш для дедупликации
- `IsPublic` — bool
- `ExpiresAt` — DateTime (nullable), для временных файлов
- `DownloadCount` — int

### POST /api/files/upload
Загрузка одного файла:

**Параметры:**
- `IFormFile file` — файл из multipart/form-data
- `bool isPublic` — публичный доступ
- `DateTime? expiresAt` — время истечения

**Валидация файла:**
1. **Размер:** максимум 50MB (настраиваемый)
2. **Тип файла (whitelist):**
   - Изображения: .jpg, .jpeg, .png, .gif, .webp
   - Документы: .pdf, .doc, .docx, .xls, .xlsx
   - Другие разрешённые типы для вашего проекта
3. **Magic bytes проверка:**
   - Прочитать первые байты файла
   - Проверить соответствие ContentType
   - Защита от подделки расширения
4. **Имя файла:**
   - Проверка на path traversal (../, ..\)
   - Запрещённые символы
   - Длина имени

**Обработка файла:**
1. Генерация безопасного имени:
   - Guid.NewGuid() + оригинальное расширение
   - Сохранение оригинального имени в БД
2. Структурированное хранение:
   - По годам/месяцам/дням: 2025/01/15/
   - ИЛИ по UserId: users/{userId}/
3. Вычисление SHA256 хеша
4. Проверка дубликатов по хешу (опционально)
5. Сохранение на диск
6. Создание записи в БД
7. Для изображений: генерация thumbnails (см. задание 3)

**Авторизация:**
- `[Authorize]` — только авторизованные
- UploadedBy = текущий UserId

**Возврат:**
- FileMetadataDTO с Id, OriginalFileName, Size, Url

### POST /api/files/upload-multiple
Загрузка нескольких файлов:

**Параметры:**
- `List<IFormFile> files`

**Обработка:**
- Валидация каждого файла
- Сохранение всех файлов
- Возврат списка FileMetadataDTO
- Если один файл не прошёл валидацию — отклонить все (транзакция)

**Ограничения:**
- Максимум 10 файлов за раз
- Общий размер не более 100MB

### GET /api/files
Список файлов пользователя:
- `[Authorize]`
- Пагинация
- Фильтр по ContentType (изображения, документы)
- Сортировка по дате загрузки
- Поиск по OriginalFileName
- Админ видит все файлы

### GET /api/files/{id}
Скачивание файла:

**Проверки:**
1. Файл существует
2. Не истёк (ExpiresAt)
3. Права доступа:
   - IsPublic == true — всем
   - UploadedBy == currentUser — владельцу
   - Admin — всем

**Возврат:**
- File() с содержимым
- Правильный Content-Type
- Content-Disposition: attachment или inline
- Имя файла из OriginalFileName

**Дополнительно:**
- Инкремент DownloadCount
- Логирование скачивания

### GET /api/files/{id}/info
Метаданные файла без скачивания:
- Возврат FileMetadataDTO
- Проверка прав доступа

### DELETE /api/files/{id}
Удаление файла:

**Проверки:**
- Владелец (UploadedBy == currentUser)
- ИЛИ Admin

**Действия:**
1. Удалить файл с диска
2. Удалить thumbnails (если есть)
3. Удалить запись из БД
4. ИЛИ soft delete (IsDeleted = true)

---

## Задание 2. Streaming больших файлов

### GET /api/files/{id}/stream
Потоковая отдача файла:

**Отличие от обычного скачивания:**
- Не загружает весь файл в память
- Отправляет chunks по мере чтения с диска
- Поддерживает Range requests

**Реализация:**
- Используйте FileStream
- Установите BufferSize (например, 4KB)
- Копируйте в Response.Body асинхронно

**Range Requests поддержка:**
1. Проверить наличие Range header
2. Парсить диапазон (bytes=0-1023)
3. Установить статус 206 Partial Content
4. Установить headers:
   - Accept-Ranges: bytes
   - Content-Range: bytes 0-1023/total
   - Content-Length: размер диапазона
5. Отправить только запрошенный диапазон

**Применение:**
- Для файлов >10MB обязательно используйте streaming
- Видео и аудио (для поддержки seek)
- Докачка прерванных загрузок

### POST /api/files/upload/chunked
Chunk upload для очень больших файлов (>10MB):

**Параметры:**
- `IFormFile chunk` — часть файла
- `string uploadId` — уникальный ID загрузки
- `int chunkIndex` — номер части
- `int totalChunks` — общее количество частей
- `string fileName` — оригинальное имя

**Логика:**
1. Сохранить chunk во временную папку
2. Записать метаданные о прогрессе
3. Когда все chunks загружены:
   - Собрать файл из частей
   - Валидировать полный файл
   - Переместить в постоянное хранилище
   - Очистить временные файлы
4. Возврат прогресса: загружено chunks / totalChunks

**Возврат:**
- При неполной загрузке: прогресс
- При завершении: FileMetadataDTO

---

## Задание 3. Работа с изображениями

### Автоматическая генерация thumbnails
При загрузке изображения создавайте превью:

**Размеры:**
- Small: 200x200 (для списков, аватары)
- Medium: 800x600 (для галерей)
- ИЛИ другие размеры для вашего проекта

**Реализация:**
Используйте библиотеку (выбрать одну):
- SixLabors.ImageSharp (рекомендуется)
- System.Drawing.Common (только Windows)
- SkiaSharp

**Процесс:**
1. Проверить что файл — изображение
2. Загрузить в Image объект
3. Resize с сохранением пропорций:
   - Fit — вписать в размер
   - Crop — обрезать до размера
   - Pad — добавить поля
4. Оптимизация качества (JPEG quality 85-90%)
5. Сохранить рядом с оригиналом:
   - original.jpg
   - original_small.jpg
   - original_medium.jpg
6. Сохранить пути в БД (или генерировать динамически)

### GET /api/files/{id}/thumbnail
Получение превью изображения:

**Query параметры:**
- `size` — small, medium (или конкретные размеры)

**Логика:**
1. Проверить что файл — изображение
2. Проверить права доступа
3. Проверить существование thumbnail
4. Если нет — сгенерировать на лету (и сохранить)
5. Вернуть thumbnail файл

**Cache headers:**
- Cache-Control: public, max-age=31536000
- ETag для кеширования на клиенте

### Оптимизация изображений
При загрузке оптимизируйте оригинал:
- Уменьшение качества JPEG (90%)
- Удаление EXIF данных (для приватности)
- Конвертация в WebP (опционально)
- Удаление метаданных

### Определение размеров
Сохраняйте в FileMetadata:
- Width — ширина в пикселях
- Height — высота в пикселях

Используется для:
- Отображение на фронтенде без загрузки
- Валидация размеров (мин/макс)

### EXIF данные (опционально)
Извлечение и сохранение:
- DateTaken — дата съёмки
- CameraModel — модель камеры
- Location — GPS координаты
- Orientation — ориентация

**Важно:** удалите перед публикацией если IsPublic!

### Поддержка форматов
Обрабатывайте форматы:
- JPEG (.jpg, .jpeg)
- PNG (.png)
- GIF (.gif) — без анимации для thumbnails
- WebP (.webp)

---

## Задание 4. Интеграция файлов с основным функционалом

### Прикрепление файлов к сущностям
Создайте связи с вашими основными сущностями.

**Примеры:**

**Для чата — MessageAttachment:**
- MessageId — FK к Message
- FileId — FK к FileMetadata
- AttachedAt — DateTime

**Для соцсети — PostAttachment:**
- PostId — FK к Post
- FileId — FK к FileMetadata
- Order — int (порядок отображения)

**Для магазина — ProductImage:**
- ProductId — FK к Product
- FileId — FK к FileMetadata
- IsMain — bool (главное фото)
- Order — int

### Endpoints с файлами
Расширьте существующие endpoints:

**POST /api/messages** (для чата):**
- Добавьте `List<Guid> attachmentIds` в DTO
- Проверьте что файлы существуют
- Проверьте что файлы принадлежат пользователю
- Создайте MessageAttachment записи

**POST /api/posts** (для соцсети):**
- `List<Guid> imageIds`
- Проверки
- Создание PostAttachment

**GET /api/messages/{id}:**
- Include attachments
- В DTO добавить список FileMetadataDTO

### Галерея изображений
Для сущностей с изображениями:

**GET /api/products/{id}/images:**
- Все изображения продукта
- Отсортированные по Order
- С URL для thumbnail и полного размера

**POST /api/products/{id}/images:**
- Загрузка и привязка изображения
- Установка Order

**DELETE /api/products/{id}/images/{imageId}:**
- Отвязка изображения
- Опционально: удаление файла

### Preview в API ответах
В ResponseDTO добавьте:
- `ThumbnailUrl` — для быстрого отображения
- `FileUrl` — для полного файла
- `FileSize` — для отображения размера
- `FileType` — для иконки

### Каскадное удаление
При удалении родительской сущности:

**Вариант А — удалить файлы:**
- Установите OnDelete(DeleteBehavior.Cascade)
- В обработчике удаления сущности удалите физические файлы

**Вариант B — архивировать:**
- Soft delete для FileMetadata
- Периодическая очистка старых файлов (background job)

---


## Задание 6. Дополнительные возможности

### Прогресс загрузки
Для больших файлов (chunk upload):
- Endpoint для проверки прогресса
- GET /api/files/upload/{uploadId}/progress
- Возврат: процент загрузки


### Дубликаты файлов
Проверка по хешу:
- При загрузке вычислить SHA256
- Найти файл с таким же хешем
- Если найден — вернуть существующий
- Экономия места на диске

---

## Задание 7. Unit-тесты (минимум 40% покрытия)

