# Аутентификация и авторизация в ASP.NET Core

## 1. Введение: Основы (3 минуты)

Прежде чем начать, важно понять два ключевых понятия:

### Аутентификация (Authentication) - "Кто ты?"
Это процесс **проверки личности** пользователя. Когда пользователь вводит логин и пароль, система проверяет: "Действительно ли ты тот, за кого себя выдаешь?"

**Примеры:**
- Вход в систему по логину/паролю
- Вход через отпечаток пальца
- Вход через Google/Facebook

### Авторизация (Authorization) - "Что тебе можно?"
Это процесс **проверки прав доступа** уже аутентифицированного пользователя. После того как система узнала кто ты, она проверяет: "Имеешь ли ты право делать это действие?"

**Примеры:**
- Может ли пользователь удалять статьи?
- Может ли пользователь видеть раздел администрирования?
- Может ли пользователь редактировать чужие комментарии?

**Важно:** Авторизация всегда идет ПОСЛЕ аутентификации. Нельзя проверить права пользователя, не зная кто он.

---

## 2. Безопасность паролей (12 минут)

### 2.1 Почему нельзя хранить пароли в открытом виде?

```csharp
// ❌ НИКОГДА ТАК НЕ ДЕЛАЙТЕ!
public class User
{
    public int Id { get; set; }
    public string Username { get; set; }
    public string Password { get; set; } // Открытый пароль!
}
```

**Проблемы:**
1. Утечка БД = утечка всех паролей
2. Администраторы БД могут видеть пароли
3. Пользователи часто используют один пароль везде

### 2.2 Хеширование паролей

**Хеш-функция** - это односторонняя функция, которая превращает пароль в случайную строку фиксированной длины. Невозможно получить пароль обратно из хеша.

```
"MyPassword123" -> хеш-функция -> "a3f8d9e2c1b7..."
```

**Свойства хеш-функции:**
- Один и тот же пароль всегда дает один и тот же хеш
- Из хеша невозможно восстановить пароль
- Даже маленькое изменение пароля полностью меняет хеш

### 2.3 Современные алгоритмы хеширования

#### PBKDF2 (Password-Based Key Derivation Function 2)

Стандарт, рекомендованный NIST. Использует много итераций, чтобы замедлить атаки перебором.

```csharp
using System.Security.Cryptography;
using System.Text;

public class PBKDF2Example
{
    public static (string hash, string salt) HashPassword(string password)
    {
        // Генерируем случайную соль
        byte[] saltBytes = new byte[32];
        using (var rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(saltBytes);
        }
        
        // Хешируем пароль с солью
        using (var pbkdf2 = new Rfc2898DeriveBytes(
            password: password,
            salt: saltBytes,
            iterations: 100000, // Количество итераций
            hashAlgorithm: HashAlgorithmName.SHA256))
        {
            byte[] hashBytes = pbkdf2.GetBytes(32); // 32 байта = 256 бит
            
            return (
                hash: Convert.ToBase64String(hashBytes),
                salt: Convert.ToBase64String(saltBytes)
            );
        }
    }
    
    public static bool VerifyPassword(string password, string hash, string salt)
    {
        byte[] saltBytes = Convert.FromBase64String(salt);
        byte[] hashBytes = Convert.FromBase64String(hash);
        
        using (var pbkdf2 = new Rfc2898DeriveBytes(
            password: password,
            salt: saltBytes,
            iterations: 100000,
            hashAlgorithm: HashAlgorithmName.SHA256))
        {
            byte[] testHash = pbkdf2.GetBytes(32);
            
            // Сравниваем байты (защита от timing attacks)
            return CryptographicOperations.FixedTimeEquals(testHash, hashBytes);
        }
    }
}
```

#### bcrypt

Популярен благодаря адаптивной сложности - можно увеличивать количество итераций со временем.

```csharp
// Установите пакет: dotnet add package BCrypt.Net-Next
using BCrypt.Net;

public class BCryptExample
{
    public static string HashPassword(string password)
    {
        // workFactor определяет сложность (рекомендуется 11-12)
        // Соль генерируется автоматически внутри
        return BCrypt.HashPassword(password, workFactor: 12);
    }
    
    public static bool VerifyPassword(string password, string hash)
    {
        return BCrypt.Verify(password, hash);
    }
}

// Пример использования:
string password = "MySecurePassword123!";
string hash = BCryptExample.HashPassword(password);
// hash: "$2a$12$KIXx8VZMf0QGd.aaOjF8AeYf..." (соль уже внутри!)

bool isValid = BCryptExample.VerifyPassword("MySecurePassword123!", hash); // true
bool isInvalid = BCryptExample.VerifyPassword("WrongPassword", hash); // false
```

#### Argon2 (Рекомендуется!)

Победитель Password Hashing Competition 2015. Защищен от атак на GPU и ASIC. Использует много памяти и процессорного времени.

```csharp
// Установите пакет: dotnet add package Isopoh.Cryptography.Argon2
using Isopoh.Cryptography.Argon2;

public class Argon2Example
{
    public static string HashPassword(string password)
    {
        var config = new Argon2Config
        {
            Type = Argon2Type.DataIndependentAddressing, // Argon2id
            Version = Argon2Version.Nineteen,
            TimeCost = 3,        // Количество итераций
            MemoryCost = 65536,  // 64 MB памяти
            Lanes = 4,           // Параллельность
            Threads = 2,         // Количество потоков
            Password = Encoding.UTF8.GetBytes(password),
            Salt = GenerateSalt(),
            HashLength = 32      // Длина хеша в байтах
        };
        
        using (var argon2 = new Argon2(config))
        {
            using (var hash = argon2.Hash())
            {
                // Возвращаем хеш в формате, который содержит все параметры
                return config.EncodeString(hash.Buffer);
            }
        }
    }
    
    public static bool VerifyPassword(string password, string hash)
    {
        return Argon2.Verify(hash, password);
    }
    
    private static byte[] GenerateSalt()
    {
        byte[] salt = new byte[16];
        using (var rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(salt);
        }
        return salt;
    }
}

// Пример использования:
string password = "MySecurePassword123!";
string hash = Argon2Example.HashPassword(password);
// hash: "$argon2id$v=19$m=65536,t=3,p=4$..." (содержит все параметры)

bool isValid = Argon2Example.VerifyPassword("MySecurePassword123!", hash); // true
```

**Какой алгоритм выбрать?**
- **Argon2** - лучший выбор для новых проектов (2024-2025)
- **bcrypt** - хороший выбор, проверенный временем
- **PBKDF2** - минимальный стандарт, но уступает Argon2

### 2.4 Что такое соль (Salt)?

**Соль** - это случайные данные, которые добавляются к паролю перед хешированием.

**Зачем нужна соль?**

```csharp
// БЕЗ соли:
Hash("password123") = "xyz789abc456..."
Hash("password123") = "xyz789abc456..." // Одинаковые хеши!

// С солью:
Hash("password123" + "salt1") = "abc123def456..."
Hash("password123" + "salt2") = "xyz789ghi012..." // Разные хеши!
```

**Защита от атак:**
1. **Rainbow Tables** - предвычисленные таблицы хешей популярных паролей
2. **Атака по словарю** - сложнее угадать, если у каждого пользователя уникальная соль

**Правила использования соли:**
- ✅ Генерировать случайную соль для КАЖДОГО пользователя
- ✅ Хранить соль вместе с хешем (это не секрет!)
- ✅ Соль должна быть достаточно длинной (минимум 16 байт)

```csharp
// Правильная модель User в БД
public class User
{
    public int Id { get; set; }
    public string Username { get; set; }
    public string PasswordHash { get; set; } // Хеш пароля
    public string PasswordSalt { get; set; } // Соль (не секретна!)
}
```

### 2.5 Краткий обзор готовых решений

#### ASP.NET Core Identity

Встроенное решение в ASP.NET Core, которое уже содержит:
- Хеширование паролей (по умолчанию PBKDF2, можно переключить на Argon2)
- Управление пользователями
- Роли и claims
- Two-factor authentication
- Email подтверждение

```csharp
// Достаточно добавить в Program.cs:
builder.Services.AddIdentity<ApplicationUser, IdentityRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>();
```

#### Keycloak

Внешний Identity Provider - отдельный сервис для управления пользователями:
- Централизованное управление пользователями
- Single Sign-On (SSO)
- OAuth 2.0 / OpenID Connect
- Федерация с внешними провайдерами (Google, Facebook)

Используется когда у вас несколько приложений, и нужна единая система аутентификации.

#### Постквантовая криптография

С развитием квантовых компьютеров современные криптографические алгоритмы могут стать уязвимыми.

**NIST стандарты** (2024):
- **CRYSTALS-Kyber** - для шифрования
- **CRYSTALS-Dilithium** - для цифровых подписей
- **SPHINCS+** - альтернативные подписи

Для паролей это менее критично (Argon2 остается безопасным), но важно для TLS/SSL и цифровых подписей.

---

## 3. Аутентификация в ASP.NET Core (18 минут)

### 3.1 Basic Authentication

**Basic Authentication** - простейший механизм аутентификации, где логин и пароль передаются в каждом запросе.

#### Как это работает?

1. Клиент отправляет логин и пароль в заголовке `Authorization`
2. Формат: `Authorization: Basic base64(username:password)`
3. Сервер декодирует и проверяет credentials

```csharp
// Пример заголовка:
// Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=
// где "dXNlcm5hbWU6cGFzc3dvcmQ=" это base64("username:password")

public class BasicAuthenticationHandler : AuthenticationHandler<AuthenticationSchemeOptions>
{
    private readonly IUserService _userService;
    
    public BasicAuthenticationHandler(
        IOptionsMonitor<AuthenticationSchemeOptions> options,
        ILoggerFactory logger,
        UrlEncoder encoder,
        ISystemClock clock,
        IUserService userService)
        : base(options, logger, encoder, clock)
    {
        _userService = userService;
    }
    
    protected override async Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        // Проверяем наличие заголовка Authorization
        if (!Request.Headers.ContainsKey("Authorization"))
        {
            return AuthenticateResult.Fail("Missing Authorization Header");
        }
        
        try
        {
            var authHeader = Request.Headers["Authorization"].ToString();
            
            // Проверяем что это Basic auth
            if (!authHeader.StartsWith("Basic ", StringComparison.OrdinalIgnoreCase))
            {
                return AuthenticateResult.Fail("Invalid Authorization Header");
            }
            
            // Декодируем base64
            var encodedCredentials = authHeader.Substring("Basic ".Length).Trim();
            var decodedCredentials = Encoding.UTF8.GetString(
                Convert.FromBase64String(encodedCredentials));
            
            // Разделяем username:password
            var credentials = decodedCredentials.Split(':', 2);
            var username = credentials[0];
            var password = credentials[1];
            
            // Проверяем credentials
            var user = await _userService.ValidateCredentials(username, password);
            if (user == null)
            {
                return AuthenticateResult.Fail("Invalid Username or Password");
            }
            
            // Создаем claims для пользователя
            var claims = new[]
            {
                new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
                new Claim(ClaimTypes.Name, user.Username),
            };
            
            var identity = new ClaimsIdentity(claims, Scheme.Name);
            var principal = new ClaimsPrincipal(identity);
            var ticket = new AuthenticationTicket(principal, Scheme.Name);
            
            return AuthenticateResult.Success(ticket);
        }
        catch (Exception ex)
        {
            return AuthenticateResult.Fail($"Error: {ex.Message}");
        }
    }
}

// Регистрация в Program.cs:
builder.Services.AddAuthentication("BasicAuthentication")
    .AddScheme<AuthenticationSchemeOptions, BasicAuthenticationHandler>(
        "BasicAuthentication", null);
```

#### Плюсы Basic Auth:
- ✅ Простота реализации
- ✅ Стандартизирован (HTTP RFC 7617)
- ✅ Работает без cookies

#### Минусы Basic Auth:
- ❌ Credentials передаются в каждом запросе
- ❌ Требуется HTTPS (иначе пароль виден в открытом виде)
- ❌ Нет logout (браузер кеширует credentials)
- ❌ Нет механизма истечения сессии

#### Когда использовать:
- Внутренние API между микросервисами
- Простые сценарии с низкими требованиями к безопасности
- Быстрые прототипы

### 3.2 JWT (JSON Web Tokens)

**JWT** - это современный стандарт для stateless аутентификации. Токен содержит всю информацию о пользователе и не требует хранения сессии на сервере.

#### Структура JWT

JWT состоит из трех частей, разделенных точками:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

[    Header    ].[         Payload         ].[      Signature      ]
```

**1. Header (Заголовок):**
```json
{
  "alg": "HS256",      // Алгоритм подписи
  "typ": "JWT"         // Тип токена
}
```

**2. Payload (Полезная нагрузка):**
```json
{
  "sub": "1234567890",           // Subject (ID пользователя)
  "name": "John Doe",            // Имя пользователя
  "role": "Admin",               // Роль
  "email": "john@example.com",   // Email
  "exp": 1735689600,             // Expiration time (Unix timestamp)
  "iat": 1735603200              // Issued at (когда создан)
}
```

**3. Signature (Подпись):**
```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret_key
)
```

Подпись гарантирует, что токен не был изменен.

#### Stateless аутентификация

```
Традиционная (Stateful):
┌────────┐                 ┌────────┐
│ Client │ ─── Login ────> │ Server │
│        │                 │  [SessionID: "abc123"]  │
│        │ <── Cookie ──── │  User: { id: 1, ... }   │
└────────┘                 └────────┘
                                ↓
                         [Хранится в памяти/БД]

JWT (Stateless):
┌────────┐                 ┌────────┐
│ Client │ ─── Login ────> │ Server │
│        │                 │  [Проверяет пароль]     │
│        │ <── Token ───── │  Создает JWT            │
│  [Хранит JWT]           └────────┘
└────────┘
    │
    └─── Request + JWT ──> Сервер просто проверяет подпись!
                           Не нужно искать в БД
```

#### Access Token vs Refresh Token

**Access Token:**
- Короткое время жизни (5-15 минут)
- Передается в каждом запросе
- Содержит claims пользователя
- Хранится в памяти клиента

**Refresh Token:**
- Долгое время жизни (дни, недели)
- Используется только для получения нового Access Token
- Хранится в БД на сервере
- Может быть отозван (invalidated)

```
┌────────┐                          ┌────────┐
│ Client │ ─── Login ──────────────> │ Server │
│        │ <── Access + Refresh ──── │        │
│        │                           └────────┘
│        │
│  [Access Token истек]
│        │
│        │ ─── Refresh Token ──────> Проверяет в БД
│        │ <── Новый Access Token ─── Выдает новый
└────────┘
```

#### Время жизни токенов

```csharp
public class TokenSettings
{
    // Access Token - короткий срок
    public static readonly TimeSpan AccessTokenLifetime = TimeSpan.FromMinutes(15);
    
    // Refresh Token - длинный срок
    public static readonly TimeSpan RefreshTokenLifetime = TimeSpan.FromDays(7);
}

// Почему разные сроки?
// 1. Access Token часто передается - риск перехвата выше
// 2. Refresh Token используется редко и проверяется в БД
// 3. При компрометации Access Token он истечет через 15 минут
// 4. Refresh Token можно отозвать в БД
```

#### Где хранить токены?

**На клиенте (браузер):**

```javascript
// ❌ НЕ РЕКОМЕНДУЕТСЯ: localStorage
// Уязвимо к XSS атакам
localStorage.setItem('accessToken', token);

// ✅ ЛУЧШЕ: httpOnly cookie
// Недоступно для JavaScript, защищено от XSS
// Сервер устанавливает:
Response.Cookies.Append("accessToken", token, new CookieOptions
{
    HttpOnly = true,      // Недоступно для JS
    Secure = true,        // Только HTTPS
    SameSite = SameSiteMode.Strict,  // Защита от CSRF
    Expires = DateTimeOffset.UtcNow.AddMinutes(15)
});

// ✅ ИЛИ: В памяти приложения (для SPA)
// Токен хранится в переменной JavaScript
// Теряется при перезагрузке страницы
let accessToken = null;
```

**На сервере:**

```csharp
// Refresh токены ВСЕГДА хранятся в БД
public class RefreshToken
{
    public int Id { get; set; }
    public string Token { get; set; }          // Случайная строка
    public int UserId { get; set; }            // Владелец
    public DateTime ExpiresAt { get; set; }    // Срок действия
    public DateTime CreatedAt { get; set; }    // Когда создан
    public string? ReplacedByToken { get; set; } // Для ротации
    public bool IsRevoked { get; set; }        // Отозван?
}
```

---

## 4. Практическая реализация JWT в ASP.NET Core (17 минут)

### 4.1 Endpoint Login - аутентификация пользователя

Создадим контроллер для входа в систему:

```csharp
[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IUserService _userService;
    private readonly ITokenService _tokenService;
    
    public AuthController(IUserService userService, ITokenService tokenService)
    {
        _userService = userService;
        _tokenService = tokenService;
    }
    
    [HttpPost("login")]
    public async Task<IActionResult> Login([FromBody] LoginRequest request)
    {
        // 1. Валидация входных данных
        if (string.IsNullOrEmpty(request.Username) || 
            string.IsNullOrEmpty(request.Password))
        {
            return BadRequest(new { message = "Username and password are required" });
        }
        
        // 2. Находим пользователя в БД
        var user = await _userService.GetByUsernameAsync(request.Username);
        if (user == null)
        {
            // НЕ говорим что пользователь не найден (безопасность)
            return Unauthorized(new { message = "Invalid credentials" });
        }
        
        // 3. Проверяем хеш пароля с использованием Argon2
        bool isPasswordValid = Argon2.Verify(user.PasswordHash, request.Password);
        if (!isPasswordValid)
        {
            return Unauthorized(new { message = "Invalid credentials" });
        }
        
        // 4. Генерируем токены
        var accessToken = _tokenService.GenerateAccessToken(user);
        var refreshToken = await _tokenService.GenerateRefreshTokenAsync(user.Id);
        
        // 5. Возвращаем токены
        return Ok(new LoginResponse
        {
            AccessToken = accessToken,
            RefreshToken = refreshToken,
            ExpiresIn = 900 // 15 минут в секундах
        });
    }
}

// Модели запроса и ответа
public class LoginRequest
{
    public string Username { get; set; }
    public string Password { get; set; }
}

public class LoginResponse
{
    public string AccessToken { get; set; }
    public string RefreshToken { get; set; }
    public int ExpiresIn { get; set; }
}
```

**UserService для работы с пользователями:**

```csharp
public interface IUserService
{
    Task<User?> GetByUsernameAsync(string username);
    Task<User?> GetByIdAsync(int id);
}

public class UserService : IUserService
{
    private readonly ApplicationDbContext _context;
    
    public UserService(ApplicationDbContext context)
    {
        _context = context;
    }
    
    public async Task<User?> GetByUsernameAsync(string username)
    {
        return await _context.Users
            .FirstOrDefaultAsync(u => u.Username == username);
    }
    
    public async Task<User?> GetByIdAsync(int id)
    {
        return await _context.Users
            .FirstOrDefaultAsync(u => u.Id == id);
    }
}

// Модель User
public class User
{
    public int Id { get; set; }
    public string Username { get; set; }
    public string Email { get; set; }
    public string PasswordHash { get; set; }  // Хеш Argon2
    public string Role { get; set; }          // "Admin", "User", etc.
    public DateTime CreatedAt { get; set; }
    
    // Навигационное свойство для токенов
    public List<RefreshToken> RefreshTokens { get; set; }
}
```

### 4.2 Генерация токенов

**Настройка в Program.cs:**

```csharp
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;

var builder = WebApplication.CreateBuilder(args);

// Настройки JWT из appsettings.json
var jwtSettings = builder.Configuration.GetSection("JwtSettings");
var secretKey = jwtSettings["SecretKey"]; // Минимум 32 символа!
var issuer = jwtSettings["Issuer"];       // "https://myapp.com"
var audience = jwtSettings["Audience"];   // "https://myapp.com"

// Добавляем аутентификацию JWT
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,           // Проверять издателя
        ValidateAudience = true,         // Проверять аудиторию
        ValidateLifetime = true,         // Проверять срок действия
        ValidateIssuerSigningKey = true, // Проверять подпись
        
        ValidIssuer = issuer,
        ValidAudience = audience,
        IssuerSigningKey = new SymmetricSecurityKey(
            Encoding.UTF8.GetBytes(secretKey)),
        
        ClockSkew = TimeSpan.Zero  // Убираем допуск времени (по умолчанию 5 минут)
    };
});

builder.Services.AddAuthorization();

// Регистрируем сервисы
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddScoped<ITokenService, TokenService>();

var app = builder.Build();

// ВАЖНО: порядок middleware имеет значение!
app.UseAuthentication();  // Сначала аутентификация
app.UseAuthorization();   // Потом авторизация

app.MapControllers();
app.Run();
```

**appsettings.json:**

```json
{
  "JwtSettings": {
    "SecretKey": "YourSuperSecretKeyThatIsAtLeast32CharactersLong!",
    "Issuer": "https://myapp.com",
    "Audience": "https://myapp.com",
    "AccessTokenExpirationMinutes": 15,
    "RefreshTokenExpirationDays": 7
  }
}
```

**TokenService для генерации токенов:**

```csharp
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;

public interface ITokenService
{
    string GenerateAccessToken(User user);
    Task<string> GenerateRefreshTokenAsync(int userId);
    Task<RefreshToken?> ValidateRefreshTokenAsync(string token);
}

public class TokenService : ITokenService
{
    private readonly IConfiguration _configuration;
    private readonly ApplicationDbContext _context;
    
    public TokenService(IConfiguration configuration, ApplicationDbContext context)
    {
        _configuration = configuration;
        _context = context;
    }
    
    public string GenerateAccessToken(User user)
    {
        var jwtSettings = _configuration.GetSection("JwtSettings");
        var secretKey = jwtSettings["SecretKey"];
        var issuer = jwtSettings["Issuer"];
        var audience = jwtSettings["Audience"];
        var expirationMinutes = int.Parse(
            jwtSettings["AccessTokenExpirationMinutes"]);
        
        // Создаем claims (утверждения о пользователе)
        var claims = new[]
        {
            new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
            new Claim(JwtRegisteredClaimNames.Email, user.Email),
            new Claim(ClaimTypes.Name, user.Username),
            new Claim(ClaimTypes.Role, user.Role),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()), // Уникальный ID токена
            new Claim(JwtRegisteredClaimNames.Iat, 
                DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString()) // Время создания
        };
        
        // Создаем ключ подписи
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey));
        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
        
        // Создаем токен
        var token = new JwtSecurityToken(
            issuer: issuer,
            audience: audience,
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(expirationMinutes),
            signingCredentials: credentials
        );
        
        // Преобразуем в строку
        return new JwtSecurityTokenHandler().WriteToken(token);
    }
    
    public async Task<string> GenerateRefreshTokenAsync(int userId)
    {
        var jwtSettings = _configuration.GetSection("JwtSettings");
        var expirationDays = int.Parse(
            jwtSettings["RefreshTokenExpirationDays"]);
        
        // Генерируем криптографически стойкую случайную строку
        var randomBytes = new byte[64];
        using (var rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(randomBytes);
        }
        var tokenString = Convert.ToBase64String(randomBytes);
        
        // Создаем запись в БД
        var refreshToken = new RefreshToken
        {
            Token = tokenString,
            UserId = userId,
            CreatedAt = DateTime.UtcNow,
            ExpiresAt = DateTime.UtcNow.AddDays(expirationDays),
            IsRevoked = false
        };
        
        _context.RefreshTokens.Add(refreshToken);
        await _context.SaveChangesAsync();
        
        return tokenString;
    }
    
    public async Task<RefreshToken?> ValidateRefreshTokenAsync(string token)
    {
        var refreshToken = await _context.RefreshTokens
            .Include(rt => rt.User)
            .FirstOrDefaultAsync(rt => rt.Token == token);
        
        // Проверки
        if (refreshToken == null)
            return null;
        
        if (refreshToken.IsRevoked)
            return null;
        
        if (refreshToken.ExpiresAt < DateTime.UtcNow)
            return null;
        
        return refreshToken;
    }
}
```

**Пример использования токена в клиенте:**

```javascript
// JavaScript (fetch API)
const response = await fetch('https://api.myapp.com/api/protected', {
    method: 'GET',
    headers: {
        'Authorization': `Bearer ${accessToken}`
        // ^^^^ Формат: "Bearer <токен>"
    }
});
```

```csharp
// C# (HttpClient)
var client = new HttpClient();
client.DefaultRequestHeaders.Authorization = 
    new AuthenticationHeaderValue("Bearer", accessToken);

var response = await client.GetAsync("https://api.myapp.com/api/protected");
```

### 4.3 Хранение Refresh токенов с Entity Framework

**Модель RefreshToken:**

```csharp
public class RefreshToken
{
    public int Id { get; set; }
    
    [Required]
    [MaxLength(200)]
    public string Token { get; set; }  // Случайная строка
    
    public int UserId { get; set; }
    public User User { get; set; }     // Навигационное свойство
    
    public DateTime CreatedAt { get; set; }
    public DateTime ExpiresAt { get; set; }
    
    public bool IsRevoked { get; set; }  // Отозван ли токен?
    
    // Для ротации токенов (опционально)
    public string? ReplacedByToken { get; set; }
    public DateTime? RevokedAt { get; set; }
}
```

**DbContext:**

```csharp
public class ApplicationDbContext : DbContext
{
    public DbSet<User> Users { get; set; }
    public DbSet<RefreshToken> RefreshTokens { get; set; }
    
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Настройка связи User -> RefreshTokens (один ко многим)
        modelBuilder.Entity<RefreshToken>()
            .HasOne(rt => rt.User)
            .WithMany(u => u.RefreshTokens)
            .HasForeignKey(rt => rt.UserId)
            .OnDelete(DeleteBehavior.Cascade);  // При удалении пользователя удаляем токены
        
        // Индекс для быстрого поиска по токену
        modelBuilder.Entity<RefreshToken>()
            .HasIndex(rt => rt.Token)
            .IsUnique();
        
        // Индекс для очистки истекших токенов
        modelBuilder.Entity<RefreshToken>()
            .HasIndex(rt => rt.ExpiresAt);
    }
}
```

**Endpoint для обновления токена:**

```csharp
[HttpPost("refresh")]
public async Task<IActionResult> RefreshToken([FromBody] RefreshTokenRequest request)
{
    // 1. Проверяем refresh token в БД
    var refreshToken = await _tokenService.ValidateRefreshTokenAsync(
        request.RefreshToken);
    
    if (refreshToken == null)
    {
        return Unauthorized(new { message = "Invalid or expired refresh token" });
    }
    
    // 2. Получаем пользователя
    var user = await _userService.GetByIdAsync(refreshToken.UserId);
    if (user == null)
    {
        return Unauthorized(new { message = "User not found" });
    }
    
    // 3. Ротация токенов (опционально, но рекомендуется)
    // Отзываем старый refresh token
    refreshToken.IsRevoked = true;
    refreshToken.RevokedAt = DateTime.UtcNow;
    
    // 4. Генерируем новые токены
    var newAccessToken = _tokenService.GenerateAccessToken(user);
    var newRefreshToken = await _tokenService.GenerateRefreshTokenAsync(user.Id);
    
    // Связываем старый токен с новым (для безопасности)
    refreshToken.ReplacedByToken = newRefreshToken;
    await _context.SaveChangesAsync();
    
    return Ok(new LoginResponse
    {
        AccessToken = newAccessToken,
        RefreshToken = newRefreshToken,
        ExpiresIn = 900
    });
}

public class RefreshTokenRequest
{
    public string RefreshToken { get; set; }
}
```

**Ротация refresh токенов (Refresh Token Rotation):**

Это практика, когда при каждом обновлении access token'а мы также выдаем новый refresh token и отзываем старый.

```
Время      Клиент                         Сервер
─────      ──────                         ──────
T0         Login
           ├─> Access Token 1 (истекает T1)
           └─> Refresh Token A
           
T1         Access Token 1 истек
           Отправляет Refresh Token A
           ├─> Access Token 2 (истекает T2)
           └─> Refresh Token B
                                          Refresh Token A отозван
                                          
T2         Access Token 2 истек
           Отправляет Refresh Token B
           ├─> Access Token 3
           └─> Refresh Token C
                                          Refresh Token B отозван
```

**Зачем нужна ротация?**
1. Если refresh token украден, он может быть использован только один раз
2. Когда сервер видит использование отозванного токена - это сигнал об атаке
3. Можно отозвать всю цепочку токенов

**Logout (отзыв токена):**

```csharp
[Authorize]  // Требуется аутентификация
[HttpPost("logout")]
public async Task<IActionResult> Logout([FromBody] RefreshTokenRequest request)
{
    // Отзываем refresh token
    var refreshToken = await _context.RefreshTokens
        .FirstOrDefaultAsync(rt => rt.Token == request.RefreshToken);
    
    if (refreshToken != null)
    {
        refreshToken.IsRevoked = true;
        refreshToken.RevokedAt = DateTime.UtcNow;
        await _context.SaveChangesAsync();
    }
    
    // Access token автоматически истечет через 15 минут
    // Или можно добавить blacklist (см. ниже)
    
    return Ok(new { message = "Logged out successfully" });
}
```

**Blacklist для Access Token (опционально):**

Так как access token stateless, его нельзя просто отозвать. Но можно создать blacklist:

```csharp
public class TokenBlacklist
{
    public int Id { get; set; }
    public string TokenJti { get; set; }  // JTI из токена (уникальный ID)
    public DateTime ExpiresAt { get; set; }
}

// В TokenService добавляем проверку:
public async Task<bool> IsTokenBlacklisted(string jti)
{
    return await _context.TokenBlacklist
        .AnyAsync(tb => tb.TokenJti == jti && tb.ExpiresAt > DateTime.UtcNow);
}

// И добавляем в middleware проверку blacklist
```

**Периодическая очистка истекших токенов:**

```csharp
// Background service для очистки
public class TokenCleanupService : BackgroundService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<TokenCleanupService> _logger;
    
    public TokenCleanupService(
        IServiceProvider serviceProvider,
        ILogger<TokenCleanupService> logger)
    {
        _serviceProvider = serviceProvider;
        _logger = logger;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _serviceProvider.CreateScope();
                var context = scope.ServiceProvider
                    .GetRequiredService<ApplicationDbContext>();
                
                // Удаляем истекшие токены (старше 30 дней)
                var cutoffDate = DateTime.UtcNow.AddDays(-30);
                var expiredTokens = await context.RefreshTokens
                    .Where(rt => rt.ExpiresAt < cutoffDate || 
                                 (rt.IsRevoked && rt.RevokedAt < cutoffDate))
                    .ToListAsync(stoppingToken);
                
                context.RefreshTokens.RemoveRange(expiredTokens);
                await context.SaveChangesAsync(stoppingToken);
                
                _logger.LogInformation(
                    "Cleaned up {Count} expired refresh tokens", 
                    expiredTokens.Count);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error cleaning up refresh tokens");
            }
            
            // Запускаем раз в день
            await Task.Delay(TimeSpan.FromDays(1), stoppingToken);
        }
    }
}

// Регистрация в Program.cs:
builder.Services.AddHostedService<TokenCleanupService>();
```

### 4.4 OAuth 2.0

**OAuth 2.0** - это протокол авторизации, который позволяет делегировать аутентификацию третьей стороне (Google, Facebook, GitHub и т.д.).

#### Основная идея:

```
Вместо:
  Пользователь → Вводит пароль в вашем приложении
  
OAuth:
  Пользователь → Входит через Google → Google подтверждает личность → 
  → Ваше приложение получает данные пользователя →
  → Ваше приложение выдаёт СВОИ токены
```

#### Важно понимать!

Google OAuth даёт вам токен **для доступа к Google API**, а не для аутентификации в **вашем** приложении. Вам нужно:
1. Получить данные пользователя от Google (email, имя)
2. Найти или создать пользователя в **вашей** БД
3. Выдать **свои** JWT токены (Access + Refresh)

#### Полный flow OAuth 2.0 с вашими токенами:

```
┌─────────┐                  ┌──────────┐                ┌────────┐
│ Client  │                  │  Ваш     │                │ Google │
│ (SPA)   │                  │ Backend  │                │        │
└─────────┘                  └──────────┘                └────────┘
     │                             │                          │
     │ 1. GET /auth/google         │                          │
     ├────────────────────────────>│                          │
     │                             │                          │
     │ 2. Redirect to Google       │                          │
     │<────────────────────────────┤                          │
     │                             │                          │
     │ 3. Пользователь вводит логин/пароль Google             │
     ├────────────────────────────────────────────────────────>│
     │                             │                          │
     │ 4. Redirect back with code  │                          │
     │<────────────────────────────────────────────────────────┤
     │                             │                          │
     │ 5. GET /auth/google/callback?code=xyz                  │
     ├────────────────────────────>│                          │
     │                             │ 6. Exchange code for     │
     │                             │    Google Access Token   │
     │                             ├─────────────────────────>│
     │                             │<─────────────────────────┤
     │                             │                          │
     │                             │ 7. Get user info         │
     │                             ├─────────────────────────>│
     │                             │<─────────────────────────┤
     │                             │ (email, name, picture)   │
     │                             │                          │
     │                             │ 8. FindOrCreate user     │
     │                             │    in YOUR database      │
     │                             │                          │
     │                             │ 9. Generate YOUR tokens  │
     │                             │    (Access + Refresh)    │
     │                             │                          │
     │ 10. Return YOUR JWT tokens  │                          │
     │<────────────────────────────┤                          │
     │                             │                          │
     │ 11. Все последующие запросы │                          │
     │     с ВАШИМ Access Token    │                          │
     ├────────────────────────────>│                          │
```

#### Реализация OAuth 2.0 с Google:

**Шаг 1: Настройка Google OAuth в Program.cs:**

```csharp
// Program.cs
builder.Services.AddAuthentication(options =>
{
    // Для OAuth мы используем Cookie для промежуточного хранения
    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = GoogleDefaults.AuthenticationScheme;
})
.AddCookie(options =>
{
    // Cookie только для OAuth flow, не для основной аутентификации!
    options.ExpireTimeSpan = TimeSpan.FromMinutes(5);
    options.SlidingExpiration = false;
})
.AddGoogle(options =>
{
    options.ClientId = builder.Configuration["Google:ClientId"];
    options.ClientSecret = builder.Configuration["Google:ClientSecret"];
    options.CallbackPath = "/api/auth/google/callback";
    
    // Запрашиваем доступ к email и профилю
    options.Scope.Add("email");
    options.Scope.Add("profile");
    
    // Сохраняем токены Google (опционально, если нужен доступ к Google API)
    options.SaveTokens = true;
});
```

**Шаг 2: Контроллер для OAuth:**

```csharp
[ApiController]
[Route("api/auth")]
public class OAuthController : ControllerBase
{
    private readonly IUserService _userService;
    private readonly ITokenService _tokenService;
    
    public OAuthController(IUserService userService, ITokenService tokenService)
    {
        _userService = userService;
        _tokenService = tokenService;
    }
    
    // Начало OAuth flow
    [HttpGet("google")]
    public IActionResult GoogleLogin()
    {
        var properties = new AuthenticationProperties
        {
            RedirectUri = Url.Action(nameof(GoogleCallback)),
            Items =
            {
                { "scheme", GoogleDefaults.AuthenticationScheme }
            }
        };
        
        // Редиректим пользователя на Google
        return Challenge(properties, GoogleDefaults.AuthenticationScheme);
    }
    
    // Callback после аутентификации в Google
    [HttpGet("google/callback")]
    public async Task<IActionResult> GoogleCallback()
    {
        // 1. Получаем результат аутентификации от Google
        var authenticateResult = await HttpContext.AuthenticateAsync(
            CookieAuthenticationDefaults.AuthenticationScheme);
        
        if (!authenticateResult.Succeeded)
        {
            return BadRequest(new { message = "Google authentication failed" });
        }
        
        // 2. Извлекаем claims от Google
        var claims = authenticateResult.Principal.Claims;
        var googleId = claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
        var email = claims.FirstOrDefault(c => c.Type == ClaimTypes.Email)?.Value;
        var name = claims.FirstOrDefault(c => c.Type == ClaimTypes.Name)?.Value;
        var picture = claims.FirstOrDefault(c => c.Type == "picture")?.Value;
        
        if (string.IsNullOrEmpty(email))
        {
            return BadRequest(new { message = "Email not provided by Google" });
        }
        
        // 3. Находим или создаём пользователя в НАШЕЙ БД
        var user = await _userService.FindOrCreateGoogleUserAsync(
            googleId: googleId,
            email: email,
            name: name,
            picture: picture
        );
        
        // 4. Генерируем НАШИ JWT токены
        var accessToken = _tokenService.GenerateAccessToken(user);
        var refreshToken = await _tokenService.GenerateRefreshTokenAsync(user.Id);
        
        // 5. Удаляем временную Cookie от OAuth flow
        await HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);
        
        // 6. Возвращаем НАШИ токены
        // Вариант A: Редирект на фронтенд с токенами в query string (для SPA)
        var frontendUrl = $"https://your-frontend.com/auth/callback" +
            $"?access_token={accessToken}" +
            $"&refresh_token={refreshToken}";
        return Redirect(frontendUrl);
        
        // Вариант B: Возвращаем JSON (если callback вызывается напрямую)
        // return Ok(new LoginResponse
        // {
        //     AccessToken = accessToken,
        //     RefreshToken = refreshToken,
        //     ExpiresIn = 900
        // });
    }
}
```

**Шаг 3: UserService для работы с Google пользователями:**

```csharp
public interface IUserService
{
    Task<User> FindOrCreateGoogleUserAsync(
        string googleId, 
        string email, 
        string name, 
        string picture);
}

public class UserService : IUserService
{
    private readonly ApplicationDbContext _context;
    
    public UserService(ApplicationDbContext context)
    {
        _context = context;
    }
    
    public async Task<User> FindOrCreateGoogleUserAsync(
        string googleId, 
        string email, 
        string name, 
        string picture)
    {
        // Ищем пользователя по Google ID или email
        var user = await _context.Users
            .FirstOrDefaultAsync(u => 
                u.GoogleId == googleId || 
                u.Email == email);
        
        if (user == null)
        {
            // Создаём нового пользователя
            user = new User
            {
                GoogleId = googleId,
                Email = email,
                Username = email.Split('@')[0], // "john@gmail.com" → "john"
                PasswordHash = null, // Нет пароля для OAuth пользователей!
                Role = "User",
                ProfilePicture = picture,
                CreatedAt = DateTime.UtcNow
            };
            
            _context.Users.Add(user);
            await _context.SaveChangesAsync();
        }
        else if (user.GoogleId == null)
        {
            // Пользователь существует по email, но без Google ID
            // Связываем его Google аккаунт
            user.GoogleId = googleId;
            user.ProfilePicture = picture;
            await _context.SaveChangesAsync();
        }
        
        return user;
    }
}

// Обновлённая модель User
public class User
{
    public int Id { get; set; }
    public string Username { get; set; }
    public string Email { get; set; }
    
    // Для обычной аутентификации
    public string? PasswordHash { get; set; }  // NULL для OAuth пользователей
    
    // Для Google OAuth
    public string? GoogleId { get; set; }      // ID от Google
    public string? ProfilePicture { get; set; } // URL картинки
    
    public string Role { get; set; }
    public DateTime CreatedAt { get; set; }
    
    public List<RefreshToken> RefreshTokens { get; set; }
}
```

**Шаг 4: Обновление Login endpoint для поддержки OAuth пользователей:**

```csharp
[HttpPost("login")]
public async Task<IActionResult> Login([FromBody] LoginRequest request)
{
    var user = await _userService.GetByUsernameAsync(request.Username);
    if (user == null)
    {
        return Unauthorized(new { message = "Invalid credentials" });
    }
    
    // Проверка: если пользователь зарегистрирован через OAuth, 
    // он не может войти по паролю
    if (user.PasswordHash == null)
    {
        return BadRequest(new 
        { 
            message = "This account was created via Google. Please use 'Sign in with Google'" 
        });
    }
    
    // Обычная проверка пароля
    bool isPasswordValid = Argon2.Verify(user.PasswordHash, request.Password);
    if (!isPasswordValid)
    {
        return Unauthorized(new { message = "Invalid credentials" });
    }
    
    var accessToken = _tokenService.GenerateAccessToken(user);
    var refreshToken = await _tokenService.GenerateRefreshTokenAsync(user.Id);
    
    return Ok(new LoginResponse
    {
        AccessToken = accessToken,
        RefreshToken = refreshToken,
        ExpiresIn = 900
    });
}
```

#### Клиентская часть (React пример):

```javascript
// Кнопка "Войти через Google"
function GoogleLoginButton() {
  const handleGoogleLogin = () => {
    // Редиректим на ваш бэкенд OAuth endpoint
    window.location.href = 'https://your-api.com/api/auth/google';
  };
  
  return (
    <button onClick={handleGoogleLogin}>
      <img src="/google-icon.svg" />
      Sign in with Google
    </button>
  );
}

// Страница callback (после редиректа)
function AuthCallback() {
  useEffect(() => {
    // Получаем токены из URL
    const params = new URLSearchParams(window.location.search);
    const accessToken = params.get('access_token');
    const refreshToken = params.get('refresh_token');
    
    if (accessToken && refreshToken) {
      // Сохраняем ВАШИ токены
      localStorage.setItem('accessToken', accessToken);
      localStorage.setItem('refreshToken', refreshToken);
      
      // Редиректим в приложение
      window.location.href = '/dashboard';
    }
  }, []);
  
  return <div>Logging in...</div>;
}
```

#### Важные моменты:

**1. Токен от Google vs Ваш токен:**
- Токен от Google даёт доступ к Google API (Gmail, Calendar, Drive)
- Ваш JWT токен даёт доступ к вашему API
- После OAuth flow клиент работает только с вашими токенами!

**2. Refresh токены:**
- Google может дать свой refresh token (если запросить offline_access)
- Вы генерируете свой refresh token и храните в БД
- Клиент использует ваш refresh token для обновления вашего access token

**3. Безопасность:**
- Никогда не передавайте Google токены клиенту напрямую
- Client Secret должен быть только на бэкенде
- Используйте state parameter для защиты от CSRF

**Когда использовать OAuth 2.0:**
- Интеграция с внешними провайдерами (Google, Facebook, GitHub)
- Single Sign-On (SSO)
- Не хотите управлять паролями пользователей
- Нужен доступ к данным пользователя из внешних сервисов (Gmail, календарь)

**Отличие JWT от OAuth:**
- JWT - это формат токена
- OAuth 2.0 - это протокол авторизации
- OAuth часто использует JWT как формат токена (но не обязательно)
- В нашем случае: OAuth для получения данных пользователя → JWT для аутентификации в вашем API

---

## 5. Авторизация в ASP.NET Core (10 минут)

После того как мы узнали **кто** пользователь (аутентификация), нужно проверить **что ему можно** (авторизация).

### 5.1 Claims-based авторизация

**Claims (утверждения)** - это пары ключ-значение, которые описывают пользователя.

```csharp
// Примеры claims:
new Claim(ClaimTypes.Name, "john.doe")
new Claim(ClaimTypes.Email, "john@example.com")
new Claim(ClaimTypes.Role, "Admin")
new Claim("Department", "Engineering")
new Claim("EmployeeId", "12345")
new Claim("CanApproveExpenses", "true")
```

#### Добавление claims в токен:

```csharp
public string GenerateAccessToken(User user)
{
    var claims = new List<Claim>
    {
        new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
        new Claim(ClaimTypes.Name, user.Username),
        new Claim(ClaimTypes.Email, user.Email),
        new Claim(ClaimTypes.Role, user.Role),
        
        // Кастомные claims
        new Claim("Department", user.Department),
        new Claim("EmployeeLevel", user.Level.ToString()),
        new Claim("CanApproveExpenses", 
            user.CanApproveExpenses.ToString().ToLower())
    };
    
    // ... остальной код создания JWT
}
```

#### Проверка claims в контроллере:

```csharp
[ApiController]
[Route("api/[controller]")]
public class ExpensesController : ControllerBase
{
    // Простая проверка - требуется аутентификация
    [Authorize]
    [HttpGet]
    public IActionResult GetMyExpenses()
    {
        // User.Identity.Name - имя пользователя из токена
        return Ok($"Expenses for {User.Identity.Name}");
    }
    
    // Проверка конкретного claim
    [Authorize(Policy = "CanApproveExpenses")]
    [HttpPost("approve/{id}")]
    public IActionResult ApproveExpense(int id)
    {
        // Этот endpoint доступен только если claim CanApproveExpenses = true
        return Ok($"Expense {id} approved");
    }
}
```

#### Настройка политик (Policies):

```csharp
// Program.cs
builder.Services.AddAuthorization(options =>
{
    // Политика: должен быть claim "CanApproveExpenses" = "true"
    options.AddPolicy("CanApproveExpenses", policy =>
        policy.RequireClaim("CanApproveExpenses", "true"));
    
    // Политика: должен быть в отделе Engineering
    options.AddPolicy("EngineeringOnly", policy =>
        policy.RequireClaim("Department", "Engineering"));
    
    // Политика: минимальный уровень сотрудника
    options.AddPolicy("MinimumLevel3", policy =>
        policy.RequireAssertion(context =>
        {
            var levelClaim = context.User.FindFirst("EmployeeLevel");
            if (levelClaim == null) return false;
            
            return int.TryParse(levelClaim.Value, out int level) && level >= 3;
        }));
});
```

**Использование в контроллере:**

```csharp
[Authorize(Policy = "EngineeringOnly")]
[HttpGet("engineering-dashboard")]
public IActionResult GetEngineeringDashboard()
{
    return Ok("Top secret engineering data");
}

[Authorize(Policy = "MinimumLevel3")]
[HttpPost("senior-action")]
public IActionResult SeniorAction()
{
    return Ok("Action available only for Level 3+ employees");
}
```

### 5.2 Role-based авторизация

**Роли** - это специальный тип claim (ClaimTypes.Role). Это самый распространенный способ авторизации.

#### Добавление ролей пользователю:

```csharp
public class User
{
    public int Id { get; set; }
    public string Username { get; set; }
    public string Role { get; set; }  // "Admin", "Manager", "User"
}

// При генерации токена:
var claims = new[]
{
    new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
    new Claim(ClaimTypes.Name, user.Username),
    new Claim(ClaimTypes.Role, user.Role)  // ← Роль
};
```

#### Использование в контроллере:

```csharp
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    // Доступно только администраторам
    [Authorize(Roles = "Admin")]
    [HttpDelete("{id}")]
    public IActionResult DeleteUser(int id)
    {
        return Ok($"User {id} deleted");
    }
    
    // Доступно администраторам И менеджерам
    [Authorize(Roles = "Admin,Manager")]
    [HttpGet("reports")]
    public IActionResult GetReports()
    {
        return Ok("Reports data");
    }
    
    // Проверка роли в коде
    [Authorize]
    [HttpGet("dashboard")]
    public IActionResult GetDashboard()
    {
        if (User.IsInRole("Admin"))
        {
            return Ok("Admin dashboard with all features");
        }
        else if (User.IsInRole("Manager"))
        {
            return Ok("Manager dashboard with limited features");
        }
        else
        {
            return Ok("User dashboard");
        }
    }
}
```

#### Множественные роли для пользователя:

Часто пользователь может иметь несколько ролей. В этом случае нужна таблица связи many-to-many:

```csharp
public class User
{
    public int Id { get; set; }
    public string Username { get; set; }
    
    // Many-to-many с ролями
    public List<UserRole> UserRoles { get; set; }
}

public class Role
{
    public int Id { get; set; }
    public string Name { get; set; }  // "Admin", "Manager", "Editor"
    
    public List<UserRole> UserRoles { get; set; }
}

public class UserRole
{
    public int UserId { get; set; }
    public User User { get; set; }
    
    public int RoleId { get; set; }
    public Role Role { get; set; }
}

// При генерации токена добавляем все роли:
var user = await _context.Users
    .Include(u => u.UserRoles)
    .ThenInclude(ur => ur.Role)
    .FirstOrDefaultAsync(u => u.Id == userId);

var claims = new List<Claim>
{
    new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
    new Claim(ClaimTypes.Name, user.Username),
};

// Добавляем claim для каждой роли
foreach (var userRole in user.UserRoles)
{
    claims.Add(new Claim(ClaimTypes.Role, userRole.Role.Name));
}
```

**Комбинирование ролей:**

```csharp
// Требуется роль Admin ИЛИ Manager
[Authorize(Roles = "Admin,Manager")]

// Требуется роль Admin И Editor одновременно
// (для этого нужна policy)
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("AdminAndEditor", policy =>
        policy.RequireRole("Admin", "Editor")); // AND логика
});

[Authorize(Policy = "AdminAndEditor")]
```

### 5.3 Policy-based авторизация (расширенная)

Policy-based авторизация позволяет создавать сложные правила проверки доступа.

#### Создание кастомного Requirement:

```csharp
// 1. Создаем требование
public class MinimumAgeRequirement : IAuthorizationRequirement
{
    public int MinimumAge { get; }
    
    public MinimumAgeRequirement(int minimumAge)
    {
        MinimumAge = minimumAge;
    }
}

// 2. Создаем обработчик требования
public class MinimumAgeHandler : AuthorizationHandler<MinimumAgeRequirement>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        MinimumAgeRequirement requirement)
    {
        // Получаем claim с датой рождения
        var dateOfBirthClaim = context.User.FindFirst(
            c => c.Type == ClaimTypes.DateOfBirth);
        
        if (dateOfBirthClaim == null)
        {
            return Task.CompletedTask;  // Не удовлетворяет требованию
        }
        
        // Парсим дату рождения
        if (!DateTime.TryParse(dateOfBirthClaim.Value, out var dateOfBirth))
        {
            return Task.CompletedTask;
        }
        
        // Вычисляем возраст
        var age = DateTime.Today.Year - dateOfBirth.Year;
        if (dateOfBirth.Date > DateTime.Today.AddYears(-age))
        {
            age--;
        }
        
        // Проверяем требование
        if (age >= requirement.MinimumAge)
        {
            context.Succeed(requirement);  // Требование выполнено!
        }
        
        return Task.CompletedTask;
    }
}

// 3. Регистрируем в Program.cs
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("Over18", policy =>
        policy.Requirements.Add(new MinimumAgeRequirement(18)));
    
    options.AddPolicy("Over21", policy =>
        policy.Requirements.Add(new MinimumAgeRequirement(21)));
});

builder.Services.AddSingleton<IAuthorizationHandler, MinimumAgeHandler>();

// 4. Используем в контроллере
[Authorize(Policy = "Over18")]
[HttpGet("adult-content")]
public IActionResult GetAdultContent()
{
    return Ok("Content for adults");
}
```

#### Более сложный пример - владение ресурсом:

```csharp
// Требование: пользователь должен быть владельцем документа
public class DocumentOwnerRequirement : IAuthorizationRequirement
{
}

public class DocumentOwnerHandler 
    : AuthorizationHandler<DocumentOwnerRequirement, Document>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        DocumentOwnerRequirement requirement,
        Document document)
    {
        // Получаем ID пользователя из токена
        var userIdClaim = context.User.FindFirst(ClaimTypes.NameIdentifier);
        if (userIdClaim == null)
        {
            return Task.CompletedTask;
        }
        
        if (!int.TryParse(userIdClaim.Value, out var userId))
        {
            return Task.CompletedTask;
        }
        
        // Проверяем владельца
        if (document.OwnerId == userId)
        {
            context.Succeed(requirement);
        }
        
        return Task.CompletedTask;
    }
}

// Регистрация
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("DocumentOwner", policy =>
        policy.Requirements.Add(new DocumentOwnerRequirement()));
});

builder.Services.AddSingleton<IAuthorizationHandler, DocumentOwnerHandler>();

// Использование в контроллере
[Authorize]
[HttpPut("documents/{id}")]
public async Task<IActionResult> UpdateDocument(
    int id,
    [FromBody] UpdateDocumentRequest request,
    [FromServices] IAuthorizationService authorizationService)
{
    // Получаем документ
    var document = await _documentService.GetByIdAsync(id);
    if (document == null)
    {
        return NotFound();
    }
    
    // Проверяем авторизацию для конкретного ресурса
    var authResult = await authorizationService.AuthorizeAsync(
        User, document, "DocumentOwner");
    
    if (!authResult.Succeeded)
    {
        return Forbid();  // 403 Forbidden
    }
    
    // Обновляем документ
    await _documentService.UpdateAsync(document, request);
    return Ok();
}
```

**Преимущества Policy-based авторизации:**
- ✅ Гибкость - можно создать любую логику
- ✅ Переиспользование - политики можно применять в разных местах
- ✅ Тестируемость - обработчики легко тестировать
- ✅ Разделение ответственности - логика авторизации отделена от контроллера

---

## Заключение

Сегодня мы рассмотрели:

1. **Безопасность паролей:**
   - Алгоритмы хеширования (PBKDF2, bcrypt, Argon2)
   - Соль и защита от rainbow tables
   - Готовые решения (Identity, Keycloak)

2. **Аутентификацию:**
   - Basic Authentication для простых сценариев
   - JWT для stateless аутентификации
   - Access Token и Refresh Token
   - Хранение и ротация токенов

3. **Авторизацию:**
   - Claims-based - гибкие утверждения о пользователе
   - Role-based - традиционные роли
   - Policy-based - сложная бизнес-логика

### Лучшие практики:

1. **Всегда используйте HTTPS** для передачи credentials и токенов
2. **Используйте Argon2** для хеширования паролей (или bcrypt как минимум)
3. **Короткий срок жизни Access Token** (15 минут)
4. **Ротация Refresh Token** при каждом обновлении
5. **Храните секретные ключи** в переменных окружения, а не в коде
6. **Логируйте попытки входа** для обнаружения атак
7. **Используйте Rate Limiting** для защиты от brute-force атак

### Дополнительные ресурсы:

- [Microsoft Docs - Authentication](https://docs.microsoft.com/aspnet/core/security/authentication/)
- [Microsoft Docs - Authorization](https://docs.microsoft.com/aspnet/core/security/authorization/)
- [JWT.io](https://jwt.io) - декодер JWT токенов
- [OWASP - Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)


