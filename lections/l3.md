# Лекция 2: Архитектура, конфигурация и работа с данными в ASP.NET Core

**Продолжительность:** 60-75 минут  
**Технологический стек:** ASP.NET Core 8.0, PostgreSQL 16, Entity Framework Core, FluentMigrator  
**Дата:** 2025

---

## 1. Введение (3 минуты)

Добро пожаловать на вторую лекцию нашего курса! Сегодня мы погрузимся в один из самых важных аспектов разработки enterprise-приложений - правильную архитектуру, конфигурацию и работу с данными.

### Почему эта тема критически важна?

Представьте, что вы строите дом. Можно начать с прочного фундамента и четкого плана, или можно просто начать класть кирпичи, надеясь, что все получится само собой. В первом случае дом простоит десятилетиями, во втором - может рухнуть при первой же буре. Абсолютно то же самое происходит с программными системами.

**Статистика говорит за себя:**
- 70% legacy-проектов имеют проблемы именно с архитектурой
- 50% времени разработки уходит на исправление архитектурных ошибок
- Правильная архитектура с самого начала экономит месяцы разработки

### Что мы изучим сегодня

**Часть 1: Конфигурация и безопасность**
- Система конфигурации ASP.NET Core и её источники
- Options Pattern для strongly-typed настроек
- Безопасное хранение секретов (User Secrets, переменные окружения)

**Часть 2: Dependency Injection**
- Как работает встроенный DI-контейнер
- Время жизни сервисов: Singleton, Scoped, Transient
- Практические примеры и типичные ошибки

**Часть 3: Архитектурные подходы**
- N-Layer Architecture: простой и понятный подход
- Clean Architecture: enterprise-решение с инверсией зависимостей
- Сравнение подходов и выбор правильного

**Часть 4: Работа с данными**
- PostgreSQL в Docker (быстрый старт для разработки)
- Entity Framework Core: настройка, DbContext, связи
- DbContext Factory для продвинутых сценариев
- FluentMigrator: автоматические миграции при запуске

**Часть 5: Паттерны доступа к данным**
- Почему Generic Repository - антипаттерн
- Когда и как использовать Specific Repository
- Unit of Work паттерн: координация транзакций

### Связь с предыдущей лекцией

На прошлой лекции мы создали простое ASP.NET Core приложение, познакомились с контроллерами, routing и основами Minimal API. Сегодня мы превратим это в масштабируемое, поддерживаемое и правильно структурированное решение, готовое к enterprise-разработке.

---

## 2. Configuration в ASP.NET Core (10 минут)

### 2.1 Система конфигурации: источники и приоритеты

ASP.NET Core имеет мощную и гибкую систему конфигурации, которая может получать настройки из множества источников. Это не просто чтение JSON-файла - это целая иерархическая система с приоритетами.

**Основные источники конфигурации (в порядке загрузки):**

1. **appsettings.json** - базовые настройки приложения
2. **appsettings.{Environment}.json** - настройки для конкретного окружения
3. **User Secrets** - локальные секреты для разработки (только Development)
4. **Environment Variables** - переменные окружения ОС
5. **Command-line Arguments** - аргументы командной строки

**Критически важно понимать порядок приоритета!**

Конфигурация загружается слоями, где каждый следующий источник **переопределяет** предыдущий:

```
[Lowest Priority]
1. appsettings.json                    ← Базовые значения
2. appsettings.{Environment}.json      ← Переопределяет #1
3. User Secrets (только Dev)           ← Переопределяет #1-2
4. Environment Variables                ← Переопределяет #1-3
5. Command-line Arguments               ← Наивысший приоритет
[Highest Priority]
```

**Практический пример:**

Допустим, в `appsettings.json` у вас:
```json
"Logging": { "LogLevel": { "Default": "Information" } }
```

А в переменных окружения:
```bash
Logging__LogLevel__Default=Debug
```

Результат: будет использоваться `Debug`, потому что переменные окружения имеют более высокий приоритет.

### 2.2 Работа с appsettings.json

Создадим структурированный файл конфигурации:

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Information"
    }
  },
  "AllowedHosts": "*",
  
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=myappdb;Username=postgres;Password=postgres",
    "RedisConnection": "localhost:6379"
  },
  
  "AppSettings": {
    "ApplicationName": "MyAwesomeApp",
    "ApplicationVersion": "1.0.0",
    "MaxItemsPerPage": 50,
    "CacheExpirationMinutes": 30,
    "EnableCache": true,
    "AllowedOrigins": [
      "https://localhost:5001",
      "https://example.com"
    ]
  },
  
  "Email": {
    "SmtpServer": "smtp.gmail.com",
    "SmtpPort": 587,
    "SenderEmail": "noreply@myapp.com",
    "SenderName": "My App",
    "EnableSsl": true
  },
  
  "Jwt": {
    "Secret": "NEVER_PUT_SECRETS_IN_APPSETTINGS",
    "Issuer": "MyApp",
    "Audience": "MyAppUsers",
    "ExpirationMinutes": 60
  }
}
```

**Лучшие практики структурирования:**

✅ Группируйте связанные настройки в секции  
✅ Используйте понятные, самоописывающиеся имена  
✅ Добавляйте комментарии для сложных параметров  
❌ Не храните секреты (пароли, API ключи) в appsettings.json  

**Чтение конфигурации в коде:**

```csharp
public class ProductsController : ControllerBase
{
    private readonly IConfiguration _configuration;
    private readonly ILogger<ProductsController> _logger;
    
    public ProductsController(IConfiguration configuration, ILogger<ProductsController> logger)
    {
        _configuration = configuration;
        _logger = logger;
    }
    
    [HttpGet]
    public IActionResult GetSettings()
    {
        // Чтение простого значения
        var appName = _configuration["AppSettings:ApplicationName"];
        
        // Чтение с значением по умолчанию
        var maxItems = _configuration.GetValue<int>("AppSettings:MaxItemsPerPage", 20);
        
        // Чтение connection string
        var connString = _configuration.GetConnectionString("DefaultConnection");
        
        // Чтение массива
        var allowedOrigins = _configuration.GetSection("AppSettings:AllowedOrigins")
            .Get<string[]>();
        
        // Чтение всей секции
        var emailSection = _configuration.GetSection("Email");
        var smtpServer = emailSection["SmtpServer"];
        var smtpPort = emailSection.GetValue<int>("SmtpPort");
        
        _logger.LogInformation("App: {AppName}, Max Items: {MaxItems}", appName, maxItems);
        
        return Ok(new { appName, maxItems, smtpServer });
    }
}
```

### 2.3 Окружения и специфичные настройки

ASP.NET Core определяет текущее окружение через переменную `ASPNETCORE_ENVIRONMENT`:

- **Development** - разработка (детальное логирование, подробные ошибки)
- **Staging** - предпродакшн (тестирование перед выкаткой)
- **Production** - продакшн (оптимизация, минимальное логирование)

**appsettings.Development.json:**
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft": "Debug"
    }
  },
  "AppSettings": {
    "EnableCache": false,
    "EnableDetailedErrors": true
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Database=myapp_dev;Username=dev;Password=dev123"
  }
}
```

**appsettings.Production.json:**
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Warning",
      "Microsoft": "Error"
    }
  },
  "AppSettings": {
    "EnableCache": true,
    "EnableDetailedErrors": false
  }
  // Connection string будет в переменных окружения!
}
```

**Проверка окружения в коде:**

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
    app.UseSwagger();
    app.UseSwaggerUI();
}
else
{
    app.UseExceptionHandler("/Error");
    app.UseHsts();
}

app.Run();
```

### 2.4 Options Pattern - Strongly-Typed Configuration

Работа с конфигурацией через строки имеет существенные недостатки:
- ❌ Нет IntelliSense и автодополнения
- ❌ Легко допустить опечатку
- ❌ Нет проверки типов на этапе компиляции
- ❌ Рефакторинг затруднен

**Options Pattern решает все эти проблемы!**

#### Шаг 1: Создание классов настроек

```csharp
// AppSettings.cs
public class AppSettings
{
    public const string SectionName = "AppSettings";
    
    public string ApplicationName { get; set; } = string.Empty;
    public string ApplicationVersion { get; set; } = string.Empty;
    public int MaxItemsPerPage { get; set; } = 20;
    public int CacheExpirationMinutes { get; set; } = 30;
    public bool EnableCache { get; set; } = true;
    public string[] AllowedOrigins { get; set; } = Array.Empty<string>();
}

// EmailSettings.cs
public class EmailSettings
{
    public const string SectionName = "Email";
    
    public string SmtpServer { get; set; } = string.Empty;
    public int SmtpPort { get; set; } = 587;
    public string SenderEmail { get; set; } = string.Empty;
    public string SenderName { get; set; } = string.Empty;
    public bool EnableSsl { get; set; } = true;
}

// JwtSettings.cs
public class JwtSettings
{
    public const string SectionName = "Jwt";
    
    public string Secret { get; set; } = string.Empty;
    public string Issuer { get; set; } = string.Empty;
    public string Audience { get; set; } = string.Empty;
    public int ExpirationMinutes { get; set; } = 60;
}
```

#### Шаг 2: Регистрация в Program.cs

```csharp
var builder = WebApplication.CreateBuilder(args);

// Регистрация Options
builder.Services.Configure<AppSettings>(
    builder.Configuration.GetSection(AppSettings.SectionName));

builder.Services.Configure<EmailSettings>(
    builder.Configuration.GetSection(EmailSettings.SectionName));

builder.Services.Configure<JwtSettings>(
    builder.Configuration.GetSection(JwtSettings.SectionName));

// Опционально: валидация при старте (.NET 8+)
builder.Services.AddOptionsWithValidateOnStart<AppSettings>()
    .Bind(builder.Configuration.GetSection(AppSettings.SectionName))
    .ValidateDataAnnotations()
    .Validate(settings => 
    {
        if (settings.MaxItemsPerPage > 1000)
        {
            return false;
        }
        return true;
    }, "MaxItemsPerPage не может быть больше 1000");
```

#### Шаг 3: Использование в коде

```csharp
public class ProductService
{
    private readonly AppSettings _appSettings;
    private readonly EmailSettings _emailSettings;
    private readonly ILogger<ProductService> _logger;
    
    // IOptions<T> - для настроек, которые НЕ меняются во время работы
    public ProductService(
        IOptions<AppSettings> appSettings,
        IOptions<EmailSettings> emailSettings,
        ILogger<ProductService> logger)
    {
        _appSettings = appSettings.Value;
        _emailSettings = emailSettings.Value;
        _logger = logger;
    }
    
    public async Task<PagedResult<Product>> GetProductsAsync(int page)
    {
        _logger.LogInformation(
            "Getting products, page: {Page}, items per page: {ItemsPerPage}",
            page, _appSettings.MaxItemsPerPage);
        
        // Используем настройку
        var pageSize = _appSettings.MaxItemsPerPage;
        
        // Бизнес-логика...
        
        return new PagedResult<Product>
        {
            Items = products,
            PageSize = pageSize,
            CurrentPage = page
        };
    }
}
```

### 2.5 Три интерфейса Options: когда использовать какой

**1. IOptions\<T\> - Singleton**
```csharp
public class MyService
{
    private readonly AppSettings _settings;
    
    public MyService(IOptions<AppSettings> options)
    {
        _settings = options.Value; // Загружается ОДИН раз при старте
    }
}
```

**Когда использовать:**
- ✅ Настройки не меняются во время работы приложения
- ✅ Самый производительный вариант
- ✅ Подходит для 90% случаев

**2. IOptionsSnapshot\<T\> - Scoped**
```csharp
public class RequestScopedService
{
    private readonly IOptionsSnapshot<AppSettings> _settingsSnapshot;
    
    public RequestScopedService(IOptionsSnapshot<AppSettings> settingsSnapshot)
    {
        _settingsSnapshot = settingsSnapshot;
    }
    
    public void DoWork()
    {
        // Перечитывается при каждом HTTP-запросе
        var currentSettings = _settingsSnapshot.Value;
    }
}
```

**Когда использовать:**
- ✅ Настройки могут измениться во время работы приложения
- ✅ Нужны актуальные значения для каждого запроса
- ⚠️ Работает только в Scoped и Transient сервисах
- ❌ Нельзя использовать в Singleton!

**3. IOptionsMonitor\<T\> - Singleton с hot-reload**
```csharp
public class CacheService
{
    private readonly IOptionsMonitor<AppSettings> _settingsMonitor;
    private IDisposable? _changeSubscription;
    
    public CacheService(IOptionsMonitor<AppSettings> settingsMonitor)
    {
        _settingsMonitor = settingsMonitor;
        
        // Подписка на изменения конфигурации
        _changeSubscription = _settingsMonitor.OnChange(settings =>
        {
            Console.WriteLine($"Настройки изменились! Новое время кэша: {settings.CacheExpirationMinutes}");
            // Можно очистить кэш, переинициализировать что-то и т.д.
        });
    }
    
    public void DoWork()
    {
        // Всегда получаем актуальное значение
        var currentSettings = _settingsMonitor.CurrentValue;
        
        // Работаем с настройками...
    }
}
```

**Когда использовать:**
- ✅ Нужен hot-reload конфигурации
- ✅ Требуется подписка на изменения
- ✅ Можно использовать в Singleton
- ⚠️ Больше overhead, чем IOptions

**Сравнительная таблица:**

| Характеристика | IOptions<T> | IOptionsSnapshot<T> | IOptionsMonitor<T> |
|---------------|-------------|---------------------|-------------------|
| Lifetime | Singleton | Scoped | Singleton |
| Перечитывание | Никогда | Каждый запрос | Real-time |
| OnChange | ❌ | ❌ | ✅ |
| Performance | ⚡⚡⚡ | ⚡⚡ | ⚡ |
| Use case | 90% случаев | Изменяемая конфиг | Hot-reload |

---

## 3. Connection Strings и безопасное хранение секретов (7 минут)

### 3.1 Connection Strings для PostgreSQL

Connection string - это строка, содержащая всю информацию для подключения к базе данных. Это критически важный элемент конфигурации, который требует особого внимания к безопасности.

**Структура Connection String для PostgreSQL:**

```
Host=localhost;Port=5432;Database=myappdb;Username=postgres;Password=mypassword;
```

**Основные параметры:**

| Параметр | Описание | Пример |
|----------|----------|--------|
| `Host` | Адрес сервера БД | `localhost`, `db.example.com`, `192.168.1.100` |
| `Port` | Порт PostgreSQL | `5432` (по умолчанию) |
| `Database` | Имя базы данных | `myappdb`, `production_db` |
| `Username` | Имя пользователя | `postgres`, `app_user` |
| `Password` | Пароль | `mypassword` (НИКОГДА в Git!) |

**Дополнительные полезные параметры:**

```
Host=localhost;
Port=5432;
Database=myappdb;
Username=postgres;
Password=mypassword;

// Connection Pooling (рекомендуется для production)
Pooling=true;
Minimum Pool Size=0;
Maximum Pool Size=100;
Connection Lifetime=0;

// Таймауты
Timeout=30;
Command Timeout=30;

// SSL (обязательно для production!)
SSL Mode=Require;
Trust Server Certificate=false;

// Дополнительные опции
Encoding=UTF8;
Application Name=MyApp;
```

**Примеры для разных окружений:**

```json
// Development
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Database=myapp_dev;Username=postgres;Password=postgres"
  }
}

// Staging
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=staging-db.internal;Database=myapp_staging;Username=app_user;Password=STORED_IN_ENV_VAR;SSL Mode=Require"
  }
}

// Production - значение в переменных окружения!
{
  "ConnectionStrings": {
    "DefaultConnection": "SET_VIA_ENVIRONMENT_VARIABLE"
  }
}
```

### 3.2 Безопасное хранение секретов

**🚨 ЗОЛОТОЕ ПРАВИЛО БЕЗОПАСНОСТИ:**

**НИКОГДА не коммитьте в Git:**
- Пароли баз данных
- API ключи
- Токены доступа
- Приватные ключи
- Любые другие секреты

#### 3.2.1 User Secrets - для Development

User Secrets - это механизм хранения секретов **локально** на машине разработчика, **вне** папки проекта.

**Инициализация User Secrets:**

```bash
# 1. Перейдите в папку проекта
cd MyApp.WebApi

# 2. Инициализируйте User Secrets
dotnet user-secrets init

# Это добавит в .csproj:
# <UserSecretsId>уникальный-guid-12345</UserSecretsId>
```

**Добавление секретов:**

```bash
# Добавление connection string
dotnet user-secrets set "ConnectionStrings:DefaultConnection" \
  "Host=localhost;Database=myapp;Username=postgres;Password=my_secret_dev_password"

# Добавление API ключа
dotnet user-secrets set "Email:ApiKey" "SG.secret_sendgrid_api_key_12345"

# Добавление JWT secret
dotnet user-secrets set "Jwt:Secret" "super-secret-jwt-signing-key-min-32-chars"

# Просмотр всех секретов
dotnet user-secrets list

# Удаление конкретного секрета
dotnet user-secrets remove "Email:ApiKey"

# Очистка ВСЕХ секретов
dotnet user-secrets clear
```

**Где хранятся User Secrets?**

User Secrets хранятся **ВНЕ** папки проекта:

```
# Windows
%APPDATA%\Microsoft\UserSecrets\<user_secrets_id>\secrets.json

# Linux / macOS
~/.microsoft/usersecrets/<user_secrets_id>/secrets.json
```

**Пример secrets.json:**
```json
{
  "ConnectionStrings:DefaultConnection": "Host=localhost;Database=myapp;Username=postgres;Password=my_secret",
  "Email:ApiKey": "SG.api_key_here",
  "Jwt:Secret": "super-secret-key-32-chars-min"
}
```

**Использование в коде:**

User Secrets автоматически загружаются в Development окружении:

```csharp
var builder = WebApplication.CreateBuilder(args);

// В Development среде User Secrets автоматически загружаются
// и переопределяют значения из appsettings.json

var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
// В Dev: получит значение из User Secrets
// В Prod: получит значение из переменных окружения

builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(connectionString));
```

#### 3.2.2 Environment Variables - для Production

В production **всегда** используем переменные окружения для секретов.

**Важно:** В переменных окружения вместо `:` используется `__` (двойное подчеркивание)

```bash
# JSON путь: ConnectionStrings:DefaultConnection
# Env переменная: ConnectionStrings__DefaultConnection

# JSON путь: Jwt:Secret
# Env переменная: Jwt__Secret

# JSON путь: AppSettings:Email:ApiKey
# Env переменная: AppSettings__Email__ApiKey
```

**Установка переменных окружения:**

**Linux/macOS:**
```bash
# Временная (только для текущей сессии)
export ConnectionStrings__DefaultConnection="Host=prod-db.com;Database=myapp;Username=app;Password=secret;SSL Mode=Require"

# Постоянная (добавить в ~/.bashrc или ~/.zshrc)
echo 'export ConnectionStrings__DefaultConnection="..."' >> ~/.bashrc
```

**Windows (PowerShell):**
```powershell
# Временная
$env:ConnectionStrings__DefaultConnection="Host=prod-db.com;..."

# Постоянная (System)
[System.Environment]::SetEnvironmentVariable("ConnectionStrings__DefaultConnection", "...", "Machine")
```

**Docker:**
```yaml
version: '3.8'
services:
  webapp:
    image: myapp:latest
    environment:
      - ConnectionStrings__DefaultConnection=Host=db;Database=myapp;Username=app;Password=${DB_PASSWORD}
      - Jwt__Secret=${JWT_SECRET}
      - ASPNETCORE_ENVIRONMENT=Production
    env_file:
      - .env.production
```

**Kubernetes:**
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: myapp-secrets
type: Opaque
data:
  connection-string: <base64-encoded-value>
  jwt-secret: <base64-encoded-value>

---
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
spec:
  containers:
  - name: myapp
    image: myapp:latest
    env:
    - name: ConnectionStrings__DefaultConnection
      valueFrom:
        secretKeyRef:
          name: myapp-secrets
          key: connection-string
```

#### 3.2.3 Облачные хранилища секретов

Для enterprise-решений используйте специализированные сервисы:

**Azure Key Vault:**
```bash
# Установка пакета
dotnet add package Azure.Extensions.AspNetCore.Configuration.Secrets

# В Program.cs
var builder = WebApplication.CreateBuilder(args);

if (!builder.Environment.IsDevelopment())
{
    var keyVaultEndpoint = new Uri(builder.Configuration["KeyVaultEndpoint"]!);
    builder.Configuration.AddAzureKeyVault(keyVaultEndpoint, new DefaultAzureCredential());
}
```

**AWS Secrets Manager:**
```bash
dotnet add package AWSSDK.SecretsManager
dotnet add package AWSSDK.Extensions.NETCore.Setup

# В Program.cs
builder.Configuration.AddSecretsManager(configurator: options =>
{
    options.SecretFilter = entry => entry.Name.StartsWith("myapp/");
    options.KeyGenerator = (entry, key) => key.Replace("__", ":");
});
```

#### 3.2.4 .gitignore - обязательные правила

Убедитесь, что в `.gitignore` есть:

```gitignore
# User secrets
**/secrets.json
**/appsettings.*.json
!**/appsettings.Development.json.example

# Environment files
.env
.env.local
.env.production
.env.*.local

# Sensitive configuration
**/connectionstrings.json
**/secrets/

# IDE
.vs/
.vscode/
.idea/
*.user
*.suo
```

### 3.3 Лучшие практики безопасности

✅ **DO:**
- Используйте User Secrets в Development
- Используйте переменные окружения в Production
- Используйте облачные Key Vault для enterprise
- Ротируйте секреты регулярно
- Используйте минимальные привилегии для БД юзеров

❌ **DON'T:**
- Коммитить секреты в Git
- Использовать одинаковые пароли для разных окружений
- Хранить секреты в appsettings.json
- Логировать секреты
- Отправлять секреты по незащищенным каналам

---

## 4. PostgreSQL в Docker (5 минут)

Прежде чем работать с базой данных в нашем приложении, нам нужна сама база данных. Самый простой и быстрый способ для разработки - использовать Docker.

### 4.1 Зачем Docker для БД в разработке?

**Преимущества:**
- ✅ Не нужно устанавливать PostgreSQL на свою машину
- ✅ Быстрое создание и удаление тестовых БД
- ✅ Изолированная среда без конфликтов
- ✅ Одинаковая версия БД у всей команды
- ✅ Легко переключаться между проектами
- ✅ Простое воссоздание с нуля

**Примечание:** Этот курс не про Docker. Мы просто покажем минимально необходимые команды для быстрого старта.

### 4.2 Запуск PostgreSQL контейнера

**Вариант 1: Простая команда docker run**

```bash
# Запуск PostgreSQL контейнера
docker run --name myapp-postgres \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=postgres \
  -e POSTGRES_DB=myappdb \
  -p 5432:5432 \
  -d postgres:16

# Объяснение параметров:
# --name myapp-postgres          → Имя контейнера
# -e POSTGRES_USER=postgres      → Имя пользователя БД
# -e POSTGRES_PASSWORD=postgres  → Пароль (для dev окружения)
# -e POSTGRES_DB=myappdb         → Имя базы данных
# -p 5432:5432                   → Проброс порта (host:container)
# -d                             → Запуск в фоновом режиме (daemon)
# postgres:16                    → Образ PostgreSQL версии 16
```

**Управление контейнером:**

```bash
# Проверка статуса контейнера
docker ps

# Остановка контейнера
docker stop myapp-postgres

# Запуск остановленного контейнера
docker start myapp-postgres

# Перезапуск
docker restart myapp-postgres

# Просмотр логов
docker logs myapp-postgres
docker logs -f myapp-postgres  # следить за логами в реальном времени

# Удаление контейнера (УДАЛИТ ВСЕ ДАННЫЕ!)
docker rm -f myapp-postgres
```

**Вариант 2: docker-compose.yml (рекомендуется)**

Создайте файл `docker-compose.yml` в корне решения:

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16
    container_name: myapp-postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: myappdb
      # Дополнительные параметры
      POSTGRES_INITDB_ARGS: "-E UTF8 --locale=en_US.utf8"
    ports:
      - "5432:5432"
    volumes:
      # Данные БД сохраняются между перезапусками
      - postgres_data:/var/lib/postgresql/data
      # Опционально: скрипты инициализации
      # - ./init-scripts:/docker-entrypoint-initdb.d
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
    driver: local
```

**Команды docker-compose:**

```bash
# Запуск всех сервисов
docker-compose up -d

# Остановка
docker-compose down

# Остановка с удалением volumes (УДАЛИТ ВСЕ ДАННЫЕ!)
docker-compose down -v

# Просмотр логов
docker-compose logs postgres
docker-compose logs -f postgres  # следить в реальном времени

# Перезапуск конкретного сервиса
docker-compose restart postgres

# Пересоздание контейнера
docker-compose up -d --force-recreate postgres
```

### 4.3 Подключение к PostgreSQL

**Из приложения:**

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=myappdb;Username=postgres;Password=postgres"
  }
}
```

**Через psql в контейнере:**

```bash
# Подключение к psql внутри контейнера
docker exec -it myapp-postgres psql -U postgres -d myappdb

# Теперь вы в интерактивной PostgreSQL консоли:
myappdb=# \dt                    -- Список таблиц
myappdb=# \d products            -- Структура таблицы products
myappdb=# \l                     -- Список баз данных
myappdb=# \du                    -- Список пользователей
myappdb=# SELECT * FROM products; -- SQL запрос
myappdb=# \q                     -- Выход
```

**Через GUI клиенты:**

1. **pgAdmin** - https://www.pgadmin.org/
   - Host: `localhost`
   - Port: `5432`
   - Username: `postgres`
   - Password: `postgres`
   - Database: `myappdb`

2. **DBeaver** - https://dbeaver.io/
   - Универсальный клиент для разных БД
   - Бесплатный и open source

3. **DataGrip** - https://www.jetbrains.com/datagrip/
   - От JetBrains
   - Платный, но мощный

### 4.4 Полезные команды PostgreSQL

```sql
-- Создание новой базы данных
CREATE DATABASE myapp_test;

-- Создание пользователя
CREATE USER app_user WITH PASSWORD 'secure_password';

-- Предоставление прав
GRANT ALL PRIVILEGES ON DATABASE myappdb TO app_user;

-- Изменение пароля
ALTER USER postgres WITH PASSWORD 'new_password';

-- Резервное копирование
-- (выполнять из хоста, не из psql)
docker exec myapp-postgres pg_dump -U postgres myappdb > backup.sql

-- Восстановление
docker exec -i myapp-postgres psql -U postgres myappdb < backup.sql
```

---

## 5. Dependency Injection в ASP.NET Core (12 минут)

Dependency Injection (DI) - это не просто паттерн, это фундаментальная часть ASP.NET Core. Понимание DI критически важно для создания масштабируемых и тестируемых приложений.

### 5.1 Что такое Dependency Injection и зачем он нужен

**Проблема без DI:**

```csharp
// ❌ Плохо - жесткая зависимость
public class OrderService
{
    private readonly EmailService _emailService;
    
    public OrderService()
    {
        _emailService = new EmailService(); // Создаем зависимость сами
    }
    
    public void CreateOrder(Order order)
    {
        // Логика создания заказа...
        _emailService.SendOrderConfirmation(order);
    }
}
```

**Проблемы этого подхода:**
- ❌ Невозможно протестировать OrderService изолированно
- ❌ Нельзя подменить EmailService на mock
- ❌ OrderService знает о конкретной реализации
- ❌ Сложно изменить реализацию EmailService
- ❌ Нарушается принцип единственной ответственности

**Решение с DI:**

```csharp
// ✅ Хорошо - зависимость инжектится
public interface IEmailService
{
    Task SendOrderConfirmation(Order order);
}

public class OrderService
{
    private readonly IEmailService _emailService;
    
    // Зависимость приходит извне (инжектится)
    public OrderService(IEmailService emailService)
    {
        _emailService = emailService;
    }
    
    public async Task CreateOrderAsync(Order order)
    {
        // Логика создания заказа...
        await _emailService.SendOrderConfirmation(order);
    }
}

// Регистрация в DI
builder.Services.AddScoped<IEmailService, EmailService>();
builder.Services.AddScoped<OrderService>();
```

**Преимущества DI:**
- ✅ Слабая связанность (loose coupling)
- ✅ Легко тестировать (можно подменять на mocks)
- ✅ Инверсия контроля (IoC)
- ✅ Переиспользование кода
- ✅ Гибкость и расширяемость

### 5.2 Время жизни сервисов (Service Lifetimes)

ASP.NET Core DI container поддерживает три времени жизни сервисов. Это **КРИТИЧЕСКИ ВАЖНО** понимать!

#### 5.2.1 Transient - Создается каждый раз

```csharp
builder.Services.AddTransient<IEmailService, EmailService>();
```

**Поведение:**
- Создается **НОВЫЙ** экземпляр при **КАЖДОМ** запросе из контейнера
- Каждое внедрение = новый объект
- Самый изолированный вариант

**Когда использовать:**
- ✅ Легковесные, stateless сервисы
- ✅ Сервисы без внутреннего состояния
- ✅ Утилитарные классы (валидаторы, маппе, хэшеры)
- ✅ Сервисы, которые НЕ должны переиспользоваться

**Примеры:**
```csharp
builder.Services.AddTransient<IPasswordHasher, BcryptPasswordHasher>();
builder.Services.AddTransient<IEmailValidator, EmailValidator>();
builder.Services.AddTransient<IMapper, AutoMapper>();
```

**Визуализация:**
```
HTTP Request 1:
  Controller → Service A (new instance)
  Controller → Service B (new instance)

HTTP Request 2:
  Controller → Service A (new instance)
  Controller → Service B (new instance)
```

#### 5.2.2 Scoped - Один на HTTP-запрос

```csharp
builder.Services.AddScoped<IProductService, ProductService>();
```

**Поведение:**
- Создается **ОДИН** экземпляр на **HTTP-запрос** (scope)
- Все зависимости в рамках одного запроса получают ОДИН И ТОТ ЖЕ экземпляр
- Dispose вызывается в конце запроса

**Когда использовать:**
- ✅ **DbContext** (ВСЕГДА!)
- ✅ Unit of Work
- ✅ Сервисы, работающие с БД в рамках запроса
- ✅ Сервисы, хранящие состояние запроса

**Примеры:**
```csharp
builder.Services.AddScoped<ApplicationDbContext>();
builder.Services.AddScoped<IUnitOfWork, UnitOfWork>();
builder.Services.AddScoped<IProductRepository, ProductRepository>();
builder.Services.AddScoped<IOrderService, OrderService>();
```

**Визуализация:**
```
HTTP Request 1:
  Controller → Service A (instance #1)
  Repository → Service A (SAME instance #1) ← Переиспользование!
  
HTTP Request 2:
  Controller → Service A (instance #2)
  Repository → Service A (SAME instance #2)
```

#### 5.2.3 Singleton - Один на всё приложение

```csharp
builder.Services.AddSingleton<ICacheService, MemoryCacheService>();
```

**Поведение:**
- Создается **ОДИН** экземпляр на **ВСЁ** приложение
- Живет от запуска до остановки приложения
- Dispose вызывается при shutdown

**Когда использовать:**
- ✅ Конфигурация (IOptions)
- ✅ Логгеры
- ✅ Кэш (Memory Cache)
- ✅ Дорогие в создании сервисы
- ✅ Глобально разделяемое состояние

**⚠️ ВАЖНО:** Singleton должны быть thread-safe!

**Примеры:**
```csharp
builder.Services.AddSingleton<IMemoryCache, MemoryCache>();
builder.Services.AddSingleton<IConfiguration>(builder.Configuration);
builder.Services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>();
```

**Визуализация:**
```
HTTP Request 1:
  Controller → Cache (singleton instance)
  
HTTP Request 2:
  Controller → Cache (SAME singleton instance)
  
HTTP Request 3:
  Controller → Cache (SAME singleton instance)
```

### 5.3 Сравнительная таблица Lifetimes

| Характеристика | Transient | Scoped | Singleton |
|---------------|-----------|--------|-----------|
| **Создание** | При каждом запросе | При каждом HTTP-запросе | При старте приложения |
| **Живет** | До Dispose | До конца HTTP-запроса | До остановки приложения |
| **Одинаковый экземпляр** | Никогда | В рамках одного запроса | Всегда |
| **Thread-safe** | Не требуется | Не требуется | **ОБЯЗАТЕЛЬНО!** |
| **Память** | Минимум | Средне | Может накапливаться |
| **Performance** | ⚡ | ⚡⚡ | ⚡⚡⚡ |
| **Типичные сценарии** | Validators, Mappers | DbContext, Repositories | Cache, Config, Loggers |

### 5.4 КРИТИЧЕСКОЕ ПРАВИЛО: Зависимости и Lifetimes

**🚨 Золотое правило:**

> Сервис может зависеть ТОЛЬКО от сервисов с ТАКИМ ЖЕ или БОЛЕЕ ДЛИННЫМ временем жизни

**Разрешено:**
```
Singleton  →  Singleton  ✅
Scoped     →  Singleton  ✅
Scoped     →  Scoped     ✅
Transient  →  Singleton  ✅
Transient  →  Scoped     ✅
Transient  →  Transient  ✅
```

**ЗАПРЕЩЕНО:**
```
Singleton  →  Scoped     ❌ ОШИБКА!
Singleton  →  Transient  ❌ ОШИБКА!
Scoped     →  Transient  ⚠️  Опасно (memory leak)
```

**Пример ОШИБКИ:**

```csharp
// ❌ ПЛОХО - Singleton зависит от Scoped
public class CacheService // Singleton
{
    private readonly IProductRepository _repository; // Scoped
    
    public CacheService(IProductRepository repository)
    {
        _repository = repository; // ОШИБКА ВРЕМЕНИ ВЫПОЛНЕНИЯ!
    }
}

// ASP.NET Core выбросит исключение:
// "Cannot consume scoped service 'IProductRepository' from singleton 'CacheService'"
```

**Правильное решение - IServiceScopeFactory:**

```csharp
// ✅ ПРАВИЛЬНО
public class CacheService
{
    private readonly IServiceScopeFactory _scopeFactory;
    
    public CacheService(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }
    
    public async Task<Product> GetProductAsync(int id)
    {
        // Создаем scope вручную
        using var scope = _scopeFactory.CreateScope();
        var repository = scope.ServiceProvider.GetRequiredService<IProductRepository>();
        
        return await repository.GetByIdAsync(id);
    }
}
```

### 5.5 Регистрация сервисов - все варианты

```csharp
var builder = WebApplication.CreateBuilder(args);

// 1. Простая регистрация интерфейс → реализация
builder.Services.AddScoped<IProductService, ProductService>();

// 2. Регистрация конкретного класса без интерфейса
builder.Services.AddScoped<ProductService>();

// 3. Generic регистрация
builder.Services.AddScoped(typeof(IRepository<>), typeof(Repository<>));

// 4. Регистрация с фабрикой
builder.Services.AddScoped<IMyService>(provider =>
{
    var config = provider.GetRequiredService<IConfiguration>();
    var logger = provider.GetRequiredService<ILogger<MyService>>();
    var connectionString = config.GetConnectionString("DefaultConnection");
    
    return new MyService(connectionString, logger);
});

// 5. Регистрация с проверкой окружения
if (builder.Environment.IsDevelopment())
{
    builder.Services.AddScoped<IEmailService, FakeEmailService>();
}
else
{
    builder.Services.AddScoped<IEmailService, SendGridEmailService>();
}

// 6. TryAdd - добавить только если еще не зарегистрировано
builder.Services.TryAddScoped<IProductService, ProductService>();

// 7. Replace - заменить существующую регистрацию
builder.Services.Replace(ServiceDescriptor.Scoped<IProductService, BetterProductService>());

// 8. RemoveAll - удалить все регистрации
builder.Services.RemoveAll<IProductService>();
```

### 5.6 Injection в разных местах

**В контроллерах (Constructor Injection):**

```csharp
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly IProductService _productService;
    private readonly ILogger<ProductsController> _logger;
    private readonly AppSettings _settings;
    
    // Все зависимости инжектятся через конструктор
    public ProductsController(
        IProductService productService,
        ILogger<ProductsController> logger,
        IOptions<AppSettings> settings)
    {
        _productService = productService;
        _logger = logger;
        _settings = settings.Value;
    }
    
    [HttpGet]
    public async Task<IActionResult> GetAllAsync()
    {
        var products = await _productService.GetAllAsync();
        return Ok(products);
    }
}
```

**В Minimal API (Parameter Injection):**

```csharp
app.MapGet("/products", async (
    IProductService productService,
    ILogger<Program> logger) =>
{
    logger.LogInformation("Getting all products");
    var products = await productService.GetAllAsync();
    return Results.Ok(products);
});

app.MapPost("/products", async (
    Product product,
    IProductService productService,
    IValidator<Product> validator) =>
{
    var validationResult = await validator.ValidateAsync(product);
    if (!validationResult.IsValid)
    {
        return Results.ValidationProblem(validationResult.ToDictionary());
    }
    
    await productService.CreateAsync(product);
    return Results.Created($"/products/{product.Id}", product);
});
```

**В Middleware:**

```csharp
public class RequestLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestLoggingMiddleware> _logger; // Singleton!
    
    // Singleton зависимости в конструкторе
    public RequestLoggingMiddleware(
        RequestDelegate next,
        ILogger<RequestLoggingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }
    
    // Scoped зависимости в методе InvokeAsync!
    public async Task InvokeAsync(
        HttpContext context,
        IProductService productService) // Scoped - через параметр метода!
    {
        _logger.LogInformation("Request: {Method} {Path}", context.Request.Method, context.Request.Path);
        
        await _next(context);
        
        _logger.LogInformation("Response: {StatusCode}", context.Response.StatusCode);
    }
}

// Регистрация
app.UseMiddleware<RequestLoggingMiddleware>();
```

**В BackgroundService:**

```csharp
public class OrderProcessingService : BackgroundService
{
    private readonly IServiceScopeFactory _scopeFactory; // Singleton
    private readonly ILogger<OrderProcessingService> _logger;
    
    public OrderProcessingService(
        IServiceScopeFactory scopeFactory,
        ILogger<OrderProcessingService> logger)
    {
        _scopeFactory = scopeFactory;
        _logger = logger;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                // Создаем scope для каждой итерации
                using var scope = _scopeFactory.CreateScope();
                var orderService = scope.ServiceProvider.GetRequiredService<IOrderService>();
                
                await orderService.ProcessPendingOrdersAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing orders");
            }
            
            await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);
        }
    }
}
```

### 5.7 Типичные ошибки с DI

**❌ Ошибка 1: Captive Dependency**

```csharp
// ❌ Singleton захватывает Scoped
builder.Services.AddSingleton<CacheService>(); // Singleton
builder.Services.AddScoped<IProductRepository, ProductRepository>(); // Scoped + DbContext

public class CacheService
{
    private readonly IProductRepository _repo; // ОШИБКА!
    
    public CacheService(IProductRepository repo)
    {
        _repo = repo; // DbContext будет жить вечно!
    }
}
```

**❌ Ошибка 2: Dispose вручную**

```csharp
// ❌ НЕ ДЕЛАЙТЕ ТАК!
public class MyController : ControllerBase
{
    public IActionResult Get()
    {
        var service = new MyService();
        var result = service.DoWork();
        service.Dispose(); // DI контейнер должен управлять временем жизни!
        return Ok(result);
    }
}
```

**❌ Ошибка 3: Static зависимости**

```csharp
// ❌ Статика нарушает DI
public class ProductService
{
    private static ILogger _logger; // ПЛОХО!
    
    public ProductService()
    {
        _logger = LoggerFactory.Create(...); // Обходим DI
    }
}
```

### 5.8 Best Practices

✅ **DO:**
- Всегда используйте интерфейсы для абстракции
- Инжектите через конструктор
- Делайте сервисы Scoped по умолчанию
- Используйте IServiceScopeFactory для Singleton → Scoped
- Регистрируйте DbContext как Scoped

❌ **DON'T:**
- Не создавайте зависимости через `new`
- Не храните Scoped в Singleton
- Не делайте Service Locator pattern
- Не инжектите HttpContext напрямую (используйте IHttpContextAccessor)
- Не Dispose сервисы вручную

---
# Лекция 2: Архитектура, конфигурация и работа с данными (Часть 2)

## 6. N-Layer Architecture (8 минут)

### 6.1 Концепция N-Layer Architecture

N-Layer (N-слойная) архитектура - это классический подход к организации кода, где приложение разделяется на горизонтальные слои с чётко определёнными обязанностями.

**Основная идея:** Разделение ответственности по техническим слоям (Presentation, Business, Data).

### 6.2 Три основных слоя

```
┌─────────────────────────────────┐
│   Presentation Layer            │  ← UI, Controllers, Views
│   (ASP.NET Core MVC/API)        │
└────────────┬────────────────────┘
             │ зависит от ↓
┌────────────┴────────────────────┐
│   Business Logic Layer          │  ← Сервисы, бизнес-правила
│   (Services, Domain Models)     │
└────────────┬────────────────────┘
             │ зависит от ↓
┌────────────┴────────────────────┐
│   Data Access Layer             │  ← DbContext, Repositories
│   (EF Core, SQL)                │
└─────────────────────────────────┘
```

**Presentation Layer (Слой представления):**
- Отвечает за взаимодействие с пользователем
- Controllers, Views (MVC), API Endpoints
- ViewModels, DTOs для передачи данных
- Валидация пользовательского ввода
- Зависит от Business Layer

**Business Logic Layer (Слой бизнес-логики):**
- Содержит бизнес-правила и логику
- Services, Domain Models
- Валидация бизнес-правил
- Координация операций
- Зависит от Data Access Layer

**Data Access Layer (Слой доступа к данным):**
- Работа с базой данных
- DbContext, Repositories
- Entities (модели БД)
- Миграции
- Не зависит ни от чего (кроме EF Core)

### 6.3 Структура проекта N-Layer

```
MyApp.sln
├── src/
│   ├── MyApp.Web/                    # Presentation Layer
│   │   ├── Controllers/
│   │   │   ├── ProductsController.cs
│   │   │   └── OrdersController.cs
│   │   ├── Models/                   # ViewModels, DTOs
│   │   │   ├── ProductViewModel.cs
│   │   │   └── OrderCreateDto.cs
│   │   ├── appsettings.json
│   │   └── Program.cs
│   │
│   ├── MyApp.Business/               # Business Logic Layer
│   │   ├── Services/
│   │   │   ├── ProductService.cs
│   │   │   └── OrderService.cs
│   │   ├── Interfaces/
│   │   │   ├── IProductService.cs
│   │   │   └── IOrderService.cs
│   │   ├── Models/                   # Business Models
│   │   │   └── OrderCalculation.cs
│   │   └── Validators/
│   │       └── ProductValidator.cs
│   │
│   └── MyApp.DataAccess/             # Data Access Layer
│       ├── Data/
│       │   └── ApplicationDbContext.cs
│       ├── Entities/                 # Database Models
│       │   ├── Product.cs
│       │   ├── Order.cs
│       │   └── OrderItem.cs
│       ├── Repositories/
│       │   ├── ProductRepository.cs
│       │   └── OrderRepository.cs
│       └── Interfaces/
│           ├── IProductRepository.cs
│           └── IOrderRepository.cs
│
└── tests/
    └── MyApp.Tests/
```

### 6.4 Пример кода N-Layer

**Data Access Layer:**
```csharp
// MyApp.DataAccess/Entities/Product.cs
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public int CategoryId { get; set; }
    public Category Category { get; set; } = null!;
}

// MyApp.DataAccess/Data/ApplicationDbContext.cs
public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options) { }
    
    public DbSet<Product> Products => Set<Product>();
    public DbSet<Category> Categories => Set<Category>();
}

// MyApp.DataAccess/Repositories/ProductRepository.cs
public class ProductRepository : IProductRepository
{
    private readonly ApplicationDbContext _context;
    
    public ProductRepository(ApplicationDbContext context)
    {
        _context = context;
    }
    
    public async Task<IEnumerable<Product>> GetAllAsync()
    {
        return await _context.Products
            .Include(p => p.Category)
            .ToListAsync();
    }
    
    public async Task<Product?> GetByIdAsync(int id)
    {
        return await _context.Products
            .Include(p => p.Category)
            .FirstOrDefaultAsync(p => p.Id == id);
    }
}
```

**Business Logic Layer:**
```csharp
// MyApp.Business/Services/ProductService.cs
public class ProductService : IProductService
{
    private readonly IProductRepository _repository;
    private readonly ILogger<ProductService> _logger;
    
    public ProductService(
        IProductRepository repository,
        ILogger<ProductService> logger)
    {
        _repository = repository;
        _logger = logger;
    }
    
    public async Task<IEnumerable<Product>> GetAllProductsAsync()
    {
        _logger.LogInformation("Getting all products");
        return await _repository.GetAllAsync();
    }
    
    public async Task<Product> CreateProductAsync(Product product)
    {
        // Бизнес-валидация
        if (product.Price < 0)
        {
            throw new BusinessException("Price cannot be negative");
        }
        
        await _repository.AddAsync(product);
        await _repository.SaveChangesAsync();
        
        _logger.LogInformation("Product created: {ProductId}", product.Id);
        return product;
    }
}
```

**Presentation Layer:**
```csharp
// MyApp.Web/Controllers/ProductsController.cs
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly IProductService _productService;
    
    public ProductsController(IProductService productService)
    {
        _productService = productService;
    }
    
    [HttpGet]
    public async Task<IActionResult> GetAll()
    {
        var products = await _productService.GetAllProductsAsync();
        return Ok(products);
    }
    
    [HttpPost]
    public async Task<IActionResult> Create([FromBody] ProductCreateDto dto)
    {
        var product = new Product
        {
            Name = dto.Name,
            Price = dto.Price,
            CategoryId = dto.CategoryId
        };
        
        await _productService.CreateProductAsync(product);
        return CreatedAtAction(nameof(GetById), new { id = product.Id }, product);
    }
}
```

### 6.5 Преимущества и недостатки N-Layer

**✅ Преимущества:**
- Простота понимания (интуитивная структура)
- Чёткое разделение ответственности
- Легко начать для небольших проектов
- Хорошо знакома большинству разработчиков
- Прямолинейная структура зависимостей

**❌ Недостатки:**
- Тесная связанность с инфраструктурой (Business зависит от Data)
- Бизнес-логика может "протекать" в Data Layer
- Сложно тестировать изолированно
- Database-first подход (модели из БД диктуют структуру)
- Domain Model зависит от ORM (EF Core entities)

### 6.6 Когда использовать N-Layer

**Подходит для:**
- ✅ CRUD-приложения с простой бизнес-логикой
- ✅ Небольшие и средние проекты
- ✅ Быстрый старт и прототипирование
- ✅ Команды, незнакомые с DDD/Clean Architecture

**Не подходит для:**
- ❌ Сложная доменная логика
- ❌ Enterprise-приложения с долгим жизненным циклом
- ❌ Проекты, где нужна высокая тестируемость
- ❌ Микросервисы с чётким разделением bounded contexts

---

## 7. Clean Architecture (8 минут)

### 7.1 Философия Clean Architecture

Clean Architecture (также известная как Onion, Hexagonal, Ports and Adapters) - это enterprise-подход к организации кода, где **бизнес-логика находится в центре**, а всё остальное - детали реализации.

**Ключевая идея:** Инверсия зависимостей - внешние слои зависят от внутренних, но не наоборот.

```
        ┌─────────────────────────┐
        │   Infrastructure        │  ← EF Core, External APIs
        └──────────┬──────────────┘
                   │ зависит от ↓
        ┌──────────┴──────────────┐
        │   Application           │  ← Use Cases, Interfaces
        └──────────┬──────────────┘
                   │ зависит от ↓
        ┌──────────┴──────────────┐
        │   Domain                │  ← Entities, Business Rules
        │   (ЯДРО, без зависимос) │
        └─────────────────────────┘
```

### 7.2 Четыре слоя Clean Architecture

#### Domain Layer (Ядро - никаких зависимостей!)

**Содержит:**
- Entities (сущности предметной области)
- Value Objects
- Domain Events
- Enums
- Domain Exceptions

**Характеристики:**
- ❌ НЕТ зависимостей на фреймворки (даже EF Core!)
- ❌ НЕТ знания про БД, UI, внешние сервисы
- ✅ Чистая бизнес-логика
- ✅ Максимально изолированный код

```csharp
// MyApp.Domain/Entities/Order.cs
public class Order // Чистая доменная модель
{
    private readonly List<OrderItem> _items = new();
    
    public int Id { get; private set; }
    public DateTime OrderDate { get; private set; }
    public OrderStatus Status { get; private set; }
    public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();
    
    public decimal TotalAmount => _items.Sum(i => i.Subtotal);
    
    // Бизнес-логика в доменной модели
    public void AddItem(Product product, int quantity)
    {
        if (quantity <= 0)
            throw new DomainException("Quantity must be positive");
        
        if (Status != OrderStatus.Draft)
            throw new DomainException("Cannot modify confirmed order");
        
        var item = new OrderItem(product, quantity);
        _items.Add(item);
    }
    
    public void Confirm()
    {
        if (!_items.Any())
            throw new DomainException("Cannot confirm empty order");
        
        Status = OrderStatus.Confirmed;
    }
}

// MyApp.Domain/ValueObjects/Money.cs
public record Money(decimal Amount, string Currency)
{
    public static Money operator +(Money a, Money b)
    {
        if (a.Currency != b.Currency)
            throw new InvalidOperationException("Cannot add different currencies");
        
        return new Money(a.Amount + b.Amount, a.Currency);
    }
}
```

#### Application Layer (Оркестрация бизнес-логики)

**Содержит:**
- Use Cases (команды и запросы)
- Интерфейсы для Infrastructure
- DTOs
- Validators
- Application Services

**Характеристики:**
- ✅ Зависит ТОЛЬКО от Domain
- ✅ Определяет интерфейсы, которые реализует Infrastructure
- ✅ Координирует выполнение бизнес-логики

```csharp
// MyApp.Application/Interfaces/IProductRepository.cs
public interface IProductRepository
{
    Task<Product?> GetByIdAsync(int id);
    Task<IEnumerable<Product>> GetAllAsync();
    Task AddAsync(Product product);
}

// MyApp.Application/UseCases/CreateOrder/CreateOrderCommand.cs
public record CreateOrderCommand(int CustomerId, List<OrderItemDto> Items);

public class CreateOrderCommandHandler
{
    private readonly IOrderRepository _orderRepository;
    private readonly IProductRepository _productRepository;
    private readonly IUnitOfWork _unitOfWork;
    
    public async Task<Order> Handle(CreateOrderCommand command)
    {
        var order = new Order(command.CustomerId);
        
        foreach (var itemDto in command.Items)
        {
            var product = await _productRepository.GetByIdAsync(itemDto.ProductId);
            if (product == null)
                throw new NotFoundException($"Product {itemDto.ProductId} not found");
            
            order.AddItem(product, itemDto.Quantity);
        }
        
        await _orderRepository.AddAsync(order);
        await _unitOfWork.SaveChangesAsync();
        
        return order;
    }
}
```

#### Infrastructure Layer (Детали реализации)

**Содержит:**
- EF Core DbContext
- Реализации репозиториев
- External API клиенты
- File system access
- Email services

**Характеристики:**
- ✅ Реализует интерфейсы из Application
- ✅ Зависит от Application и Domain
- ✅ Знает про конкретные технологии (PostgreSQL, SendGrid, etc.)

```csharp
// MyApp.Infrastructure/Persistence/ApplicationDbContext.cs
public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options) { }
    
    public DbSet<Order> Orders => Set<Order>();
    public DbSet<Product> Products => Set<Product>();
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Конфигурация для доменных моделей
        modelBuilder.Entity<Order>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.OrderDate).IsRequired();
            
            // Mapping для Value Object
            entity.OwnsOne(e => e.ShippingAddress);
            
            // Private collection
            entity.HasMany(typeof(OrderItem), "_items")
                .WithOne()
                .HasForeignKey("OrderId");
        });
    }
}

// MyApp.Infrastructure/Repositories/OrderRepository.cs
public class OrderRepository : IOrderRepository
{
    private readonly ApplicationDbContext _context;
    
    public OrderRepository(ApplicationDbContext context)
    {
        _context = context;
    }
    
    public async Task<Order?> GetByIdAsync(int id)
    {
        return await _context.Orders
            .Include("_items") // Private property
            .FirstOrDefaultAsync(o => o.Id == id);
    }
    
    public async Task AddAsync(Order order)
    {
        await _context.Orders.AddAsync(order);
    }
}
```

#### Presentation Layer (Web API / UI)

**Содержит:**
- Controllers
- API Endpoints
- Views (если MVC)
- Request/Response models

**Характеристики:**
- ✅ Зависит от Application
- ✅ НЕ зависит от Infrastructure напрямую
- ✅ Точка входа в приложение

```csharp
// MyApp.WebApi/Controllers/OrdersController.cs
[ApiController]
[Route("api/[controller]")]
public class OrdersController : ControllerBase
{
    private readonly IMediator _mediator; // MediatR для CQRS
    
    public OrdersController(IMediator mediator)
    {
        _mediator = mediator;
    }
    
    [HttpPost]
    public async Task<IActionResult> Create([FromBody] CreateOrderRequest request)
    {
        var command = new CreateOrderCommand(
            request.CustomerId,
            request.Items.Select(i => new OrderItemDto(i.ProductId, i.Quantity)).ToList()
        );
        
        var order = await _mediator.Send(command);
        
        return CreatedAtAction(nameof(GetById), new { id = order.Id }, order);
    }
}
```

### 7.3 Dependency Rule (Правило зависимостей)

**Фундаментальное правило Clean Architecture:**

> Зависимости могут указывать ТОЛЬКО ВНУТРЬ. Внутренние слои НЕ ЗНАЮТ о внешних.

```
Infrastructure → Application → Domain
    ✓              ✓            ✗
Presentation   → Application → Domain
    ✓              ✓            ✗

Domain        ✗→ Application  # ЗАПРЕЩЕНО
Application   ✗→ Infrastructure # ЗАПРЕЩЕНО
```

### 7.4 Структура проекта Clean Architecture

```
MyApp.sln
├── src/
│   ├── Core/                         # Внутренние слои
│   │   ├── MyApp.Domain/             # Domain Layer (0 зависимостей!)
│   │   │   ├── Entities/
│   │   │   │   ├── Order.cs
│   │   │   │   ├── Product.cs
│   │   │   │   └── Customer.cs
│   │   │   ├── ValueObjects/
│   │   │   │   ├── Money.cs
│   │   │   │   └── Address.cs
│   │   │   ├── Enums/
│   │   │   │   └── OrderStatus.cs
│   │   │   └── Exceptions/
│   │   │       └── DomainException.cs
│   │   │
│   │   └── MyApp.Application/        # Application Layer
│   │       ├── Interfaces/           # Интерфейсы для Infrastructure
│   │       │   ├── IOrderRepository.cs
│   │       │   ├── IEmailService.cs
│   │       │   └── IUnitOfWork.cs
│   │       ├── UseCases/
│   │       │   ├── CreateOrder/
│   │       │   │   ├── CreateOrderCommand.cs
│   │       │   │   └── CreateOrderCommandHandler.cs
│   │       │   └── GetOrders/
│   │       │       └── GetOrdersQuery.cs
│   │       ├── DTOs/
│   │       │   └── OrderDto.cs
│   │       └── Validators/
│   │           └── CreateOrderValidator.cs
│   │
│   ├── Infrastructure/               # Внешний слой
│   │   └── MyApp.Infrastructure/     # Infrastructure Layer
│   │       ├── Persistence/
│   │       │   ├── ApplicationDbContext.cs
│   │       │   ├── Configurations/
│   │       │   │   └── OrderConfiguration.cs
│   │       │   └── Migrations/
│   │       ├── Repositories/
│   │       │   ├── OrderRepository.cs
│   │       │   └── ProductRepository.cs
│   │       └── Services/
│   │           ├── EmailService.cs
│   │           └── StorageService.cs
│   │
│   └── Presentation/                 # Внешний слой
│       └── MyApp.WebApi/             # Presentation Layer
│           ├── Controllers/
│           │   └── OrdersController.cs
│           ├── Models/               # Request/Response
│           │   ├── CreateOrderRequest.cs
│           │   └── OrderResponse.cs
│           └── Program.cs
│
└── tests/
    ├── MyApp.Domain.Tests/
    ├── MyApp.Application.Tests/
    └── MyApp.Infrastructure.Tests/
```

### 7.5 Регистрация зависимостей в Clean Architecture

```csharp
// MyApp.WebApi/Program.cs
var builder = WebApplication.CreateBuilder(args);

// Application Layer
builder.Services.AddMediatR(cfg => 
    cfg.RegisterServicesFromAssembly(typeof(CreateOrderCommand).Assembly));
builder.Services.AddValidatorsFromAssembly(typeof(CreateOrderValidator).Assembly);

// Infrastructure Layer
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));

builder.Services.AddScoped<IOrderRepository, OrderRepository>();
builder.Services.AddScoped<IProductRepository, ProductRepository>();
builder.Services.AddScoped<IUnitOfWork, UnitOfWork>();
builder.Services.AddScoped<IEmailService, SendGridEmailService>();

var app = builder.Build();
```

### 7.6 Преимущества и недостатки Clean Architecture

**✅ Преимущества:**
- Независимость от фреймворков (Domain не знает про EF Core)
- Высокая тестируемость (можно тестировать Domain изолированно)
- Независимость от UI (можно заменить API на MVC без изменения Domain)
- Независимость от БД (можно поменять PostgreSQL на MongoDB)
- Гибкость и расширяемость
- Долгосрочная поддерживаемость

**❌ Недостатки:**
- Сложность на старте (больше проектов, интерфейсов)
- Overhead для простых CRUD-приложений
- Требует понимания DDD принципов
- Больше кода (интерфейсы, мапперы)
- Крутая кривая обучения для команды

### 7.7 Сравнение N-Layer vs Clean Architecture

| Аспект | N-Layer | Clean Architecture |
|--------|---------|-------------------|
| **Сложность** | Простая | Сложная |
| **Кривая обучения** | Низкая | Высокая |
| **Зависимости** | Сверху вниз | Внутрь (инверсия) |
| **Тестируемость** | Средняя | Высокая |
| **Гибкость** | Низкая | Высокая |
| **Размер проекта** | Малый/Средний | Средний/Большой |
| **Domain независимость** | ❌ | ✅ |
| **Замена инфраструктуры** | Сложно | Легко |
| **Overhead** | Низкий | Высокий |
| **Подходит для** | CRUD, прототипы | Enterprise, DDD |

### 7.8 Когда использовать Clean Architecture

**Подходит для:**
- ✅ Enterprise-приложения с долгим жизненным циклом
- ✅ Сложная доменная логика
- ✅ Проекты, где важна тестируемость
- ✅ Микросервисы с четкими bounded contexts
- ✅ Команды, знакомые с DDD

**Не подходит для:**
- ❌ Простые CRUD-приложения
- ❌ Прототипы и MVP
- ❌ Небольшие проекты с простой логикой
- ❌ Команды без опыта в DDD
- ❌ Проекты с жесткими дедлайнами

---

## 8. Entity Framework Core: Настройка и подключение (8 минут)

### 8.1 Установка пакетов

```bash
# В проекте Infrastructure/DataAccess
dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL --version 8.0.10
```

**Важно:** Версия Npgsql.EntityFrameworkCore.PostgreSQL должна соответствовать версии .NET:
- .NET 8 → Npgsql 8.x
- .NET 9 → Npgsql 9.x

### 8.2 Создание моделей (Entities)

```csharp
// Product.cs
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public decimal Price { get; set; }
    public int Stock { get; set; }
    public int CategoryId { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? UpdatedAt { get; set; }
    
    // Navigation properties
    public Category Category { get; set; } = null!;
    public ICollection<OrderItem> OrderItems { get; set; } = new List<OrderItem>();
}

// Category.cs
public class Category
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    
    public ICollection<Product> Products { get; set; } = new List<Product>();
}

// Order.cs
public class Order
{
    public int Id { get; set; }
    public DateTime OrderDate { get; set; }
    public int CustomerId { get; set; }
    public decimal TotalAmount { get; set; }
    public OrderStatus Status { get; set; }
    
    public Customer Customer { get; set; } = null!;
    public ICollection<OrderItem> Items { get; set; } = new List<OrderItem>();
}

// OrderItem.cs
public class OrderItem
{
    public int Id { get; set; }
    public int OrderId { get; set; }
    public int ProductId { get; set; }
    public int Quantity { get; set; }
    public decimal UnitPrice { get; set; }
    
    public Order Order { get; set; } = null!;
    public Product Product { get; set; } = null!;
}

public enum OrderStatus
{
    Pending,
    Confirmed,
    Shipped,
    Delivered,
    Cancelled
}
```

### 8.3 Создание DbContext

```csharp
public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }
    
    // DbSet properties
    public DbSet<Product> Products => Set<Product>();
    public DbSet<Category> Categories => Set<Category>();
    public DbSet<Order> Orders => Set<Order>();
    public DbSet<OrderItem> OrderItems => Set<OrderItem>();
    public DbSet<Customer> Customers => Set<Customer>();
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        
        // Применение всех конфигураций из сборки
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(ApplicationDbContext).Assembly);
        
        // Или настройка inline
        ConfigureProduct(modelBuilder);
        ConfigureOrder(modelBuilder);
    }
    
    private void ConfigureProduct(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Product>(entity =>
        {
            entity.ToTable("products");
            
            entity.HasKey(e => e.Id);
            
            entity.Property(e => e.Name)
                .HasMaxLength(200)
                .IsRequired();
            
            entity.Property(e => e.Description)
                .HasMaxLength(1000);
            
            entity.Property(e => e.Price)
                .HasColumnType("decimal(18,2)")
                .IsRequired();
            
            entity.Property(e => e.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP");
            
            // Индексы
            entity.HasIndex(e => e.Name);
            entity.HasIndex(e => e.CategoryId);
            
            // Связи
            entity.HasOne(e => e.Category)
                .WithMany(c => c.Products)
                .HasForeignKey(e => e.CategoryId)
                .OnDelete(DeleteBehavior.Restrict);
        });
    }
    
    private void ConfigureOrder(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Order>(entity =>
        {
            entity.ToTable("orders");
            
            entity.HasKey(e => e.Id);
            
            entity.Property(e => e.TotalAmount)
                .HasColumnType("decimal(18,2)");
            
            entity.Property(e => e.Status)
                .HasConversion<string>(); // Enum → строка в БД
            
            entity.HasMany(e => e.Items)
                .WithOne(i => i.Order)
                .HasForeignKey(i => i.OrderId)
                .OnDelete(DeleteBehavior.Cascade);
        });
    }
}
```

**Альтернатива: отдельные Configuration классы:**

```csharp
// ProductConfiguration.cs
public class ProductConfiguration : IEntityTypeConfiguration<Product>
{
    public void Configure(EntityTypeBuilder<Product> builder)
    {
        builder.ToTable("products");
        
        builder.HasKey(e => e.Id);
        
        builder.Property(e => e.Name)
            .HasMaxLength(200)
            .IsRequired();
        
        builder.Property(e => e.Price)
            .HasColumnType("decimal(18,2)");
        
        builder.HasOne(e => e.Category)
            .WithMany(c => c.Products)
            .HasForeignKey(e => e.CategoryId);
    }
}

// В OnModelCreating:
modelBuilder.ApplyConfiguration(new ProductConfiguration());
```

### 8.4 Регистрация DbContext через DI

```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);

// Базовая регистрация
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(
        builder.Configuration.GetConnectionString("DefaultConnection")));

// С дополнительными настройками
builder.Services.AddDbContext<ApplicationDbContext>(options =>
{
    options.UseNpgsql(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        npgsqlOptions =>
        {
            // Таймауты
            npgsqlOptions.CommandTimeout(30);
            
            // Retry policy
            npgsqlOptions.EnableRetryOnFailure(
                maxRetryCount: 3,
                maxRetryDelay: TimeSpan.FromSeconds(30),
                errorCodesToAdd: null);
            
            // Версия PostgreSQL
            npgsqlOptions.SetPostgresVersion(new Version(16, 0));
        });
    
    // Только для Development
    if (builder.Environment.IsDevelopment())
    {
        options.EnableSensitiveDataLogging(); // Показывает значения в логах
        options.EnableDetailedErrors(); // Детальные ошибки
        options.LogTo(Console.WriteLine, LogLevel.Information);
    }
});
```

---

## 9. DbContext Factory (5 минут)

### 9.1 Зачем нужна IDbContextFactory

**Проблема:** Scoped DbContext не подходит для некоторых сценариев:
- Background Services (Singleton)
- Parallel operations
- Длительные операции
- Создание нескольких контекстов в одном scope

**Решение:** IDbContextFactory<TContext>

### 9.2 Регистрация и использование

```csharp
// Program.cs - регистрация фабрики
builder.Services.AddDbContextFactory<ApplicationDbContext>(options =>
    options.UseNpgsql(
        builder.Configuration.GetConnectionString("DefaultConnection")));
```

**Использование в Background Service:**

```csharp
public class DataProcessingService : BackgroundService
{
    private readonly IDbContextFactory<ApplicationDbContext> _contextFactory;
    private readonly ILogger<DataProcessingService> _logger;
    
    public DataProcessingService(
        IDbContextFactory<ApplicationDbContext> contextFactory,
        ILogger<DataProcessingService> logger)
    {
        _contextFactory = contextFactory;
        _logger = logger;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                // Создаем новый контекст для каждой итерации
                await using var context = await _contextFactory.CreateDbContextAsync(stoppingToken);
                
                var pendingOrders = await context.Orders
                    .Where(o => o.Status == OrderStatus.Pending)
                    .ToListAsync(stoppingToken);
                
                foreach (var order in pendingOrders)
                {
                    // Обработка заказа
                    _logger.LogInformation("Processing order {OrderId}", order.Id);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing data");
            }
            
            await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);
        }
    }
}
```

**Параллельная обработка:**

```csharp
public class BulkOperationService
{
    private readonly IDbContextFactory<ApplicationDbContext> _contextFactory;
    
    public async Task ProcessItemsInParallelAsync(List<int> itemIds)
    {
        var tasks = itemIds.Select(async id =>
        {
            // Каждая задача получает свой собственный DbContext
            await using var context = await _contextFactory.CreateDbContextAsync();
            
            var item = await context.Items.FindAsync(id);
            if (item != null)
            {
                // Обработка...
                await context.SaveChangesAsync();
            }
        });
        
        await Task.WhenAll(tasks);
    }
}
```

### 9.3 DbContext Factory vs Scoped DbContext

| Аспект | Scoped DbContext | DbContext Factory |
|--------|-----------------|-------------------|
| **Lifetime** | Scoped (один на запрос) | Transient (создается когда нужно) |
| **Use case** | HTTP запросы, Web APIs | Background services, parallel ops |
| **Disposal** | Автоматический | Вручную (using/await using) |
| **Performance** | ⚡⚡⚡ (переиспользуется) | ⚡⚡ (создается каждый раз) |
| **Когда** | 95% случаев | Специальные сценарии |


# Лекция 2: Архитектура, конфигурация и работа с данными (Часть 3)

## 10. FluentMigrator: Миграции из кода (10 минут)

### 10.1 Что такое FluentMigrator и зачем он нужен

**FluentMigrator** - это framework для миграций баз данных с использованием Fluent API на C#.

**Основные преимущества:**
- ✅ Миграции выполняются **автоматически** при запуске приложения
- ✅ Не зависит от EF Core (можно использовать с Dapper, ADO.NET)
- ✅ Больше контроля над SQL
- ✅ Не нужны команды `dotnet ef`
- ✅ Code-first подход к миграциям
- ✅ Поддержка множества БД (PostgreSQL, SQL Server, MySQL, SQLite)

**Сравнение с EF Core Migrations:**

| Аспект | EF Core Migrations | FluentMigrator |
|--------|-------------------|----------------|
| **Автозапуск** | ❌ Нужна команда | ✅ Автоматически |
| **Зависимость от EF** | ✅ Нужен EF Core | ❌ Не нужен |
| **Контроль SQL** | Средний | Высокий |
| **Синтаксис** | Generated code | Fluent API |
| **ORM независимость** | ❌ | ✅ |

### 10.2 Установка пакетов

```bash
# Основные пакеты
dotnet add package FluentMigrator
dotnet add package FluentMigrator.Runner
dotnet add package FluentMigrator.Runner.Postgres

# Если нужно логирование
dotnet add package FluentMigrator.Extensions.Postgres
```

### 10.3 Создание миграций

**Структура миграции:**

```csharp
using FluentMigrator;

namespace MyApp.Infrastructure.Migrations
{
    // Атрибут Migration с УНИКАЛЬНЫМ номером версии
    // Формат: YYYYMMDDHHMMSS (год, месяц, день, час, минута, секунда)
    [Migration(20250121120000)]
    public class InitialMigration : Migration
    {
        // Метод Up - применение миграции
        public override void Up()
        {
            // Создание таблиц, индексов, и т.д.
        }
        
        // Метод Down - откат миграции
        public override void Down()
        {
            // Удаление созданного в Up
        }
    }
}
```

**Пример полной миграции:**

```csharp
[Migration(20250121120000)]
public class InitialMigration : Migration
{
    public override void Up()
    {
        // Создание таблицы Categories
        Create.Table("categories")
            .WithColumn("id").AsInt32().PrimaryKey().Identity()
            .WithColumn("name").AsString(200).NotNullable()
            .WithColumn("description").AsString(1000).Nullable()
            .WithColumn("created_at").AsDateTime().NotNullable()
                .WithDefault(SystemMethods.CurrentDateTime);
        
        // Создание таблицы Products
        Create.Table("products")
            .WithColumn("id").AsInt32().PrimaryKey().Identity()
            .WithColumn("name").AsString(200).NotNullable()
            .WithColumn("description").AsString(1000).Nullable()
            .WithColumn("price").AsDecimal(18, 2).NotNullable()
            .WithColumn("stock").AsInt32().NotNullable().WithDefaultValue(0)
            .WithColumn("category_id").AsInt32().NotNullable()
            .WithColumn("created_at").AsDateTime().NotNullable()
                .WithDefault(SystemMethods.CurrentDateTime)
            .WithColumn("updated_at").AsDateTime().Nullable();
        
        // Внешний ключ
        Create.ForeignKey("fk_products_category")
            .FromTable("products").ForeignColumn("category_id")
            .ToTable("categories").PrimaryColumn("id")
            .OnDelete(System.Data.Rule.Restrict);
        
        // Индексы
        Create.Index("idx_products_category")
            .OnTable("products")
            .OnColumn("category_id");
        
        Create.Index("idx_products_name")
            .OnTable("products")
            .OnColumn("name");
        
        // Unique constraint
        Create.UniqueConstraint("uq_categories_name")
            .OnTable("categories")
            .Column("name");
    }
    
    public override void Down()
    {
        // Удаление в обратном порядке
        Delete.Table("products");
        Delete.Table("categories");
    }
}
```

**Добавление новых колонок:**

```csharp
[Migration(20250121130000)]
public class AddProductIsActiveColumn : Migration
{
    public override void Up()
    {
        Alter.Table("products")
            .AddColumn("is_active").AsBoolean()
                .NotNullable()
                .WithDefaultValue(true);
    }
    
    public override void Down()
    {
        Delete.Column("is_active").FromTable("products");
    }
}
```

**Вставка данных (seeding):**

```csharp
[Migration(20250121140000)]
public class SeedInitialData : Migration
{
    public override void Up()
    {
        // Добавление категорий
        Insert.IntoTable("categories")
            .Row(new
            {
                name = "Electronics",
                description = "Electronic devices and accessories",
                created_at = DateTime.UtcNow
            })
            .Row(new
            {
                name = "Books",
                description = "Books and publications",
                created_at = DateTime.UtcNow
            });
        
        // Добавление продуктов
        Insert.IntoTable("products")
            .Row(new
            {
                name = "Laptop",
                description = "High-performance laptop",
                price = 999.99m,
                stock = 10,
                category_id = 1,
                created_at = DateTime.UtcNow
            });
    }
    
    public override void Down()
    {
        Delete.FromTable("products").AllRows();
        Delete.FromTable("categories").AllRows();
    }
}
```

**Выполнение SQL напрямую:**

```csharp
[Migration(20250121150000)]
public class AddCustomFunction : Migration
{
    public override void Up()
    {
        Execute.Sql(@"
            CREATE OR REPLACE FUNCTION calculate_order_total(order_id INT)
            RETURNS DECIMAL(18,2) AS $$
            BEGIN
                RETURN (
                    SELECT SUM(unit_price * quantity)
                    FROM order_items
                    WHERE order_id = $1
                );
            END;
            $$ LANGUAGE plpgsql;
        ");
    }
    
    public override void Down()
    {
        Execute.Sql("DROP FUNCTION IF EXISTS calculate_order_total(INT);");
    }
}
```

### 10.4 Настройка и запуск FluentMigrator

**Регистрация в Program.cs:**

```csharp
using FluentMigrator.Runner;

var builder = WebApplication.CreateBuilder(args);

// Регистрация FluentMigrator
builder.Services.AddFluentMigratorCore()
    .ConfigureRunner(rb => rb
        // Выбор провайдера БД
        .AddPostgres()
        // Connection string
        .WithGlobalConnectionString(
            builder.Configuration.GetConnectionString("DefaultConnection"))
        // Где искать миграции
        .ScanIn(typeof(Program).Assembly).For.Migrations())
    // Добавление логирования
    .AddLogging(lb => lb.AddFluentMigratorConsole());

var app = builder.Build();

// КРИТИЧНО: Запуск миграций при старте приложения
using (var scope = app.Services.CreateScope())
{
    var runner = scope.ServiceProvider.GetRequiredService<IMigrationRunner>();
    
    if (app.Environment.IsDevelopment())
    {
        // В Development всегда мигрируем к последней версии
        runner.MigrateUp();
    }
    else
    {
        // В Production можно добавить дополнительные проверки
        try
        {
            runner.MigrateUp();
        }
        catch (Exception ex)
        {
            var logger = scope.ServiceProvider.GetRequiredService<ILogger<Program>>();
            logger.LogError(ex, "Migration failed");
            throw; // Не запускаем приложение если миграция провалилась
        }
    }
}

app.Run();
```

**Вариант с опциональной миграцией через endpoint:**

```csharp
// Добавить endpoint для ручного запуска миграций
app.MapPost("/admin/migrate", async (IMigrationRunner runner) =>
{
    try
    {
        runner.MigrateUp();
        return Results.Ok(new { message = "Migrations applied successfully" });
    }
    catch (Exception ex)
    {
        return Results.Problem(
            detail: ex.Message,
            title: "Migration failed"
        );
    }
})
.RequireAuthorization("AdminOnly"); // Защитить авторизацией!
```

### 10.5 Полезные команды FluentMigrator

```csharp
// Мигрировать к последней версии
runner.MigrateUp();

// Мигрировать к конкретной версии
runner.MigrateUp(20250121120000);

// Откат последней миграции
runner.MigrateDown(0);

// Откат к конкретной версии
runner.MigrateDown(20250121120000);

// Информация о миграциях
runner.ListMigrations();
```

### 10.6 Best Practices для FluentMigrator

✅ **DO:**
- Используйте timestamp формат для номеров миграций: `YYYYMMDDHHMMSS`
- Всегда реализуйте метод `Down()` для отката
- Тестируйте миграции на копии production БД
- Делайте миграции маленькими и атомарными
- Храните миграции в Git
- Логируйте выполнение миграций

❌ **DON'T:**
- Не изменяйте уже выполненные миграции
- Не используйте одинаковые номера версий
- Не забывайте про индексы для FK
- Не делайте миграции, которые занимают часы

### 10.7 Организация миграций

**Структура папок:**

```
MyApp.Infrastructure/
├── Migrations/
│   ├── _20250121_Initial/
│   │   └── 20250121120000_InitialMigration.cs
│   ├── _20250122_Products/
│   │   ├── 20250122100000_AddProductTable.cs
│   │   └── 20250122110000_AddProductIndexes.cs
│   └── _20250123_Orders/
│       └── 20250123090000_AddOrderTables.cs
```

---

## 11. Связи между сущностями в EF Core (5 минут)

### 11.1 One-to-Many (1:N)

**Пример: Одна категория → много продуктов**

```csharp
public class Category
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    
    // Navigation property (коллекция)
    public ICollection<Product> Products { get; set; } = new List<Product>();
}

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    
    // Foreign Key
    public int CategoryId { get; set; }
    
    // Navigation property (ссылка)
    public Category Category { get; set; } = null!;
}
```

**Конфигурация:**

```csharp
modelBuilder.Entity<Product>()
    .HasOne(p => p.Category)           // У Product есть одна Category
    .WithMany(c => c.Products)         // У Category много Products
    .HasForeignKey(p => p.CategoryId)  // FK - CategoryId
    .OnDelete(DeleteBehavior.Restrict); // Запрет удаления Category с Products
```

**Варианты DeleteBehavior:**
- `Restrict` - Запрещает удаление (выбросит исключение)
- `Cascade` - Каскадное удаление (удалит все Products)
- `SetNull` - Установит FK в NULL
- `NoAction` - Ничего не делать (БД решит сама)

### 11.2 One-to-One (1:1)

**Пример: Один пользователь → один профиль**

```csharp
public class User
{
    public int Id { get; set; }
    public string Email { get; set; } = string.Empty;
    
    // Navigation property
    public UserProfile? Profile { get; set; }
}

public class UserProfile
{
    public int Id { get; set; }
    
    // Foreign Key (обязательно в dependent entity)
    public int UserId { get; set; }
    
    public string FirstName { get; set; } = string.Empty;
    public string LastName { get; set; } = string.Empty;
    public DateTime DateOfBirth { get; set; }
    
    // Navigation property
    public User User { get; set; } = null!;
}
```

**Конфигурация:**

```csharp
modelBuilder.Entity<User>()
    .HasOne(u => u.Profile)              // У User есть один Profile
    .WithOne(p => p.User)                // У Profile есть один User
    .HasForeignKey<UserProfile>(p => p.UserId); // FK в UserProfile
```

### 11.3 Many-to-Many (N:M)

**Вариант 1: Автоматическая join table (EF Core 5.0+)**

```csharp
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    
    // Navigation property - коллекция
    public ICollection<Tag> Tags { get; set; } = new List<Tag>();
}

public class Tag
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    
    // Navigation property - коллекция
    public ICollection<Product> Products { get; set; } = new List<Product>();
}
```

**Конфигурация (опционально):**

```csharp
modelBuilder.Entity<Product>()
    .HasMany(p => p.Tags)
    .WithMany(t => t.Products);
    // EF Core автоматически создаст таблицу ProductTag
```

**Вариант 2: Явная join table (больше контроля)**

```csharp
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    
    // Через join entity
    public ICollection<ProductTag> ProductTags { get; set; } = new List<ProductTag>();
}

public class Tag
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    
    // Через join entity
    public ICollection<ProductTag> ProductTags { get; set; } = new List<ProductTag>();
}

// Join entity с дополнительными полями
public class ProductTag
{
    public int ProductId { get; set; }
    public Product Product { get; set; } = null!;
    
    public int TagId { get; set; }
    public Tag Tag { get; set; } = null!;
    
    // Дополнительные поля
    public DateTime AssignedAt { get; set; }
    public string AssignedBy { get; set; } = string.Empty;
}
```

**Конфигурация:**

```csharp
modelBuilder.Entity<ProductTag>(entity =>
{
    // Composite primary key
    entity.HasKey(pt => new { pt.ProductId, pt.TagId });
    
    entity.HasOne(pt => pt.Product)
        .WithMany(p => p.ProductTags)
        .HasForeignKey(pt => pt.ProductId);
    
    entity.HasOne(pt => pt.Tag)
        .WithMany(t => t.ProductTags)
        .HasForeignKey(pt => pt.TagId);
});
```

---

## 12. Repository Pattern: Правильный подход (10 минут)

### 12.1 Почему Generic Repository - АНТИПАТТЕРН

**Generic Repository выглядит так:**

```csharp
// ❌ ЭТО АНТИПАТТЕРН!
public interface IRepository<T> where T : class
{
    Task<T?> GetByIdAsync(int id);
    Task<IEnumerable<T>> GetAllAsync();
    Task<IEnumerable<T>> FindAsync(Expression<Func<T, bool>> predicate);
    Task AddAsync(T entity);
    Task AddRangeAsync(IEnumerable<T> entities);
    void Update(T entity);
    void Delete(T entity);
    Task<int> SaveChangesAsync();
}
```

**Почему это плохо:**

1. **Дублирование функциональности**
   - DbContext и DbSet<T> УЖЕ ЯВЛЯЮТСЯ Repository и Unit of Work
   - Вы добавляете ещё один слой абстракции поверх абстракции

2. **Скрывает возможности EF Core**
   ```csharp
   // ❌ Теряем Include, AsNoTracking, и другие возможности
   var products = await repository.GetAllAsync();
   
   // ✅ С DbContext напрямую
   var products = await context.Products
       .Include(p => p.Category)
       .AsNoTracking()
       .Where(p => p.IsActive)
       .OrderBy(p => p.Name)
       .ToListAsync();
   ```

3. **Expression<Func<T, bool>> - кошмар для тестирования**
   ```csharp
   // Попробуйте замокать это!
   var products = await repository.FindAsync(p => 
       p.Category.Name == "Electronics" && 
       p.Price > 100);
   ```

4. **Нарушает принцип YAGNI (You Aren't Gonna Need It)**
   - 95% методов Generic Repository не используются
   - Но вы вынуждены их реализовывать

5. **Отсутствие бизнес-смысла**
   ```csharp
   // ❌ Что это значит?
   var items = await repository.FindAsync(x => x.Something);
   
   // ✅ Намного понятнее
   var activeProducts = await productRepo.GetActiveProductsAsync();
   ```

### 12.2 Правильный подход: Specific Repositories

**Создавайте репозитории ТОЛЬКО для сложной логики:**

```csharp
// ✅ ПРАВИЛЬНО - специфичный интерфейс
public interface IProductRepository
{
    // Только методы, которые действительно нужны
    Task<Product?> GetByIdWithCategoryAsync(int id);
    Task<IEnumerable<Product>> GetActiveProductsAsync();
    Task<IEnumerable<Product>> GetProductsByCategoryAsync(int categoryId);
    Task<IEnumerable<Product>> GetLowStockProductsAsync(int threshold);
    Task<PagedResult<Product>> SearchProductsAsync(string searchTerm, int page, int pageSize);
    Task<bool> IsProductNameUniqueAsync(string name, int? excludeId = null);
}
```

**Реализация:**

```csharp
public class ProductRepository : IProductRepository
{
    private readonly ApplicationDbContext _context;
    
    public ProductRepository(ApplicationDbContext context)
    {
        _context = context;
    }
    
    public async Task<Product?> GetByIdWithCategoryAsync(int id)
    {
        return await _context.Products
            .Include(p => p.Category)
            .AsNoTracking()
            .FirstOrDefaultAsync(p => p.Id == id);
    }
    
    public async Task<IEnumerable<Product>> GetActiveProductsAsync()
    {
        return await _context.Products
            .Where(p => p.IsActive && p.Stock > 0)
            .Include(p => p.Category)
            .OrderBy(p => p.Name)
            .AsNoTracking()
            .ToListAsync();
    }
    
    public async Task<IEnumerable<Product>> GetProductsByCategoryAsync(int categoryId)
    {
        return await _context.Products
            .Where(p => p.CategoryId == categoryId && p.IsActive)
            .Include(p => p.Category)
            .OrderBy(p => p.Name)
            .AsNoTracking()
            .ToListAsync();
    }
    
    public async Task<IEnumerable<Product>> GetLowStockProductsAsync(int threshold)
    {
        return await _context.Products
            .Where(p => p.IsActive && p.Stock <= threshold)
            .Include(p => p.Category)
            .OrderBy(p => p.Stock)
            .AsNoTracking()
            .ToListAsync();
    }
    
    public async Task<PagedResult<Product>> SearchProductsAsync(
        string searchTerm, int page, int pageSize)
    {
        var query = _context.Products
            .Where(p => p.IsActive && 
                (p.Name.Contains(searchTerm) || p.Description.Contains(searchTerm)))
            .Include(p => p.Category)
            .AsNoTracking();
        
        var totalCount = await query.CountAsync();
        
        var items = await query
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync();
        
        return new PagedResult<Product>
        {
            Items = items,
            TotalCount = totalCount,
            Page = page,
            PageSize = pageSize
        };
    }
    
    public async Task<bool> IsProductNameUniqueAsync(string name, int? excludeId = null)
    {
        var query = _context.Products.Where(p => p.Name == name);
        
        if (excludeId.HasValue)
        {
            query = query.Where(p => p.Id != excludeId.Value);
        }
        
        return !await query.AnyAsync();
    }
}
```

### 12.3 Когда НЕ нужен Repository

**Для простых CRUD операций используйте DbContext напрямую:**

```csharp
public class CategoryService
{
    private readonly ApplicationDbContext _context;
    
    public CategoryService(ApplicationDbContext context)
    {
        _context = context;
    }
    
    // Простые операции - напрямую через DbContext
    public async Task<Category?> GetByIdAsync(int id)
    {
        return await _context.Categories.FindAsync(id);
    }
    
    public async Task<List<Category>> GetAllAsync()
    {
        return await _context.Categories
            .OrderBy(c => c.Name)
            .ToListAsync();
    }
    
    public async Task<Category> CreateAsync(Category category)
    {
        _context.Categories.Add(category);
        await _context.SaveChangesAsync();
        return category;
    }
    
    public async Task UpdateAsync(Category category)
    {
        _context.Categories.Update(category);
        await _context.SaveChangesAsync();
    }
    
    public async Task DeleteAsync(int id)
    {
        var category = await _context.Categories.FindAsync(id);
        if (category != null)
        {
            _context.Categories.Remove(category);
            await _context.SaveChangesAsync();
        }
    }
}
```

### 12.4 Решение: когда использовать Repository

**✅ Используйте Repository когда:**
- Сложные запросы, которые повторяются в нескольких местах
- Нужна инкапсуляция специфичной логики доступа к данным
- Запросы с бизнес-смыслом (`GetActiveProducts`, `GetOverdueOrders`)
- Нужна абстракция для потенциальной смены БД

**❌ НЕ используйте Repository когда:**
- Простые CRUD операции
- Запрос используется только в одном месте
- Нет сложной логики
- Это просто обёртка над DbContext

---

## 13. Unit of Work Pattern (8 минут)

### 13.1 Концепция Unit of Work

**Unit of Work** координирует работу нескольких репозиториев и обеспечивает транзакционность.

**Зачем нужен:**
- Координация работы нескольких репозиториев
- Транзакционность (всё или ничего)
- Единая точка вызова SaveChanges
- Explicit transactions

### 13.2 Реализация Unit of Work

```csharp
public interface IUnitOfWork : IDisposable
{
    // Репозитории
    IProductRepository Products { get; }
    IOrderRepository Orders { get; }
    ICustomerRepository Customers { get; }
    
    // Методы
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);
    Task BeginTransactionAsync();
    Task CommitTransactionAsync();
    Task RollbackTransactionAsync();
}

public class UnitOfWork : IUnitOfWork
{
    private readonly ApplicationDbContext _context;
    private IDbContextTransaction? _transaction;
    
    // Lazy initialization репозиториев
    private IProductRepository? _productRepository;
    private IOrderRepository? _orderRepository;
    private ICustomerRepository? _customerRepository;
    
    public UnitOfWork(ApplicationDbContext context)
    {
        _context = context;
    }
    
    public IProductRepository Products
    {
        get
        {
            _productRepository ??= new ProductRepository(_context);
            return _productRepository;
        }
    }
    
    public IOrderRepository Orders
    {
        get
        {
            _orderRepository ??= new OrderRepository(_context);
            return _orderRepository;
        }
    }
    
    public ICustomerRepository Customers
    {
        get
        {
            _customerRepository ??= new CustomerRepository(_context);
            return _customerRepository;
        }
    }
    
    public async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        return await _context.SaveChangesAsync(cancellationToken);
    }
    
    public async Task BeginTransactionAsync()
    {
        _transaction = await _context.Database.BeginTransactionAsync();
    }
    
    public async Task CommitTransactionAsync()
    {
        try
        {
            await SaveChangesAsync();
            
            if (_transaction != null)
            {
                await _transaction.CommitAsync();
            }
        }
        catch
        {
            await RollbackTransactionAsync();
            throw;
        }
        finally
        {
            if (_transaction != null)
            {
                await _transaction.DisposeAsync();
                _transaction = null;
            }
        }
    }
    
    public async Task RollbackTransactionAsync()
    {
        if (_transaction != null)
        {
            await _transaction.RollbackAsync();
            await _transaction.DisposeAsync();
            _transaction = null;
        }
    }
    
    public void Dispose()
    {
        _transaction?.Dispose();
        _context.Dispose();
    }
}
```

### 13.3 Использование Unit of Work

**Регистрация:**

```csharp
builder.Services.AddScoped<IUnitOfWork, UnitOfWork>();
```

**В сервисе:**

```csharp
public class OrderService
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly ILogger<OrderService> _logger;
    
    public OrderService(IUnitOfWork unitOfWork, ILogger<OrderService> logger)
    {
        _unitOfWork = unitOfWork;
        _logger = logger;
    }
    
    public async Task<Order> CreateOrderAsync(CreateOrderDto dto)
    {
        await _unitOfWork.BeginTransactionAsync();
        
        try
        {
            // 1. Проверяем клиента
            var customer = await _unitOfWork.Customers.GetByIdAsync(dto.CustomerId);
            if (customer == null)
            {
                throw new NotFoundException("Customer not found");
            }
            
            // 2. Создаём заказ
            var order = new Order
            {
                CustomerId = dto.CustomerId,
                OrderDate = DateTime.UtcNow,
                Status = OrderStatus.Pending
            };
            
            await _unitOfWork.Orders.AddAsync(order);
            
            // 3. Добавляем позиции заказа
            decimal totalAmount = 0;
            
            foreach (var itemDto in dto.Items)
            {
                var product = await _unitOfWork.Products.GetByIdAsync(itemDto.ProductId);
                if (product == null)
                {
                    throw new NotFoundException($"Product {itemDto.ProductId} not found");
                }
                
                if (product.Stock < itemDto.Quantity)
                {
                    throw new BusinessException(
                        $"Insufficient stock for product {product.Name}");
                }
                
                // Уменьшаем запасы
                product.Stock -= itemDto.Quantity;
                await _unitOfWork.Products.UpdateAsync(product);
                
                // Добавляем позицию заказа
                var orderItem = new OrderItem
                {
                    Order = order,
                    ProductId = product.Id,
                    Quantity = itemDto.Quantity,
                    UnitPrice = product.Price
                };
                
                await _unitOfWork.Orders.AddItemAsync(orderItem);
                totalAmount += orderItem.UnitPrice * orderItem.Quantity;
            }
            
            order.TotalAmount = totalAmount;
            
            // 4. Сохраняем всё в одной транзакции
            await _unitOfWork.CommitTransactionAsync();
            
            _logger.LogInformation("Order {OrderId} created for customer {CustomerId}",
                order.Id, customer.Id);
            
            return order;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating order for customer {CustomerId}",
                dto.CustomerId);
            await _unitOfWork.RollbackTransactionAsync();
            throw;
        }
    }
}
```

### 13.4 Когда НЕ нужен Unit of Work

**DbContext уже является Unit of Work:**

```csharp
public class SimpleOrderService
{
    private readonly ApplicationDbContext _context;
    
    public async Task CreateSimpleOrderAsync(Order order)
    {
        // DbContext уже отслеживает изменения
        _context.Orders.Add(order);
        
        // SaveChanges выполняется в одной транзакции
        await _context.SaveChangesAsync();
        // ✅ Всё автоматически в транзакции!
    }
}
```

**Unit of Work нужен только для:**
- Explicit transactions (BeginTransaction)
- Координация нескольких репозиториев
- Сложная бизнес-логика с множественными операциями

---

## 14. Лучшие практики и типичные ошибки (7 минут)

### 14.1 Best Practices ✅

**Архитектура:**
```csharp
// ✅ Используйте слои правильно
public class ProductsController : ControllerBase
{
    private readonly IProductService _service; // НЕ DbContext!
    
    [HttpGet]
    public async Task<IActionResult> GetAll()
    {
        var products = await _service.GetAllAsync();
        return Ok(products);
    }
}
```

**EF Core:**
```csharp
// ✅ Всегда async
public async Task<List<Product>> GetAllAsync()
{
    return await _context.Products.ToListAsync();
}

// ✅ AsNoTracking для read-only
public async Task<IEnumerable<Product>> GetProductsAsync()
{
    return await _context.Products
        .AsNoTracking() // Не отслеживаем изменения
        .ToListAsync();
}

// ✅ Include для eager loading
public async Task<Product?> GetByIdAsync(int id)
{
    return await _context.Products
        .Include(p => p.Category)
        .Include(p => p.OrderItems)
        .FirstOrDefaultAsync(p => p.Id == id);
}
```

**Конфигурация:**
```csharp
// ✅ Secrets в User Secrets (dev) и Env Variables (prod)
// ✅ Options Pattern для strongly-typed настроек
public class MyService
{
    private readonly AppSettings _settings;
    
    public MyService(IOptions<AppSettings> options)
    {
        _settings = options.Value;
    }
}
```

### 14.2 Типичные ошибки ❌

**Ошибка 1: DbContext в контроллере**
```csharp
// ❌ ПЛОХО
public class ProductsController : ControllerBase
{
    private readonly ApplicationDbContext _context;
    
    [HttpGet]
    public async Task<IActionResult> Get()
    {
        return Ok(await _context.Products.ToListAsync());
    }
}

// ✅ ХОРОШО
public class ProductsController : ControllerBase
{
    private readonly IProductService _productService;
    
    [HttpGet]
    public async Task<IActionResult> Get()
    {
        var products = await _productService.GetAllAsync();
        return Ok(products);
    }
}
```

**Ошибка 2: N+1 Problem**
```csharp
// ❌ ПЛОХО - N+1 запросов
var products = await _context.Products.ToListAsync();
foreach (var product in products)
{
    var category = await _context.Categories.FindAsync(product.CategoryId);
    // Каждая итерация = отдельный запрос!
}

// ✅ ХОРОШО - 1 запрос
var products = await _context.Products
    .Include(p => p.Category)
    .ToListAsync();
```

**Ошибка 3: Забытый AsNoTracking**
```csharp
// ❌ ПЛОХО - tracking для read-only
public async Task<IEnumerable<Product>> GetAllAsync()
{
    return await _context.Products.ToListAsync();
    // EF Core отслеживает все изменения (overhead)
}

// ✅ ХОРОШО
public async Task<IEnumerable<Product>> GetAllAsync()
{
    return await _context.Products
        .AsNoTracking()
        .ToListAsync();
}
```

**Ошибка 4: Синхронные методы**
```csharp
// ❌ ПЛОХО - блокирует поток
public List<Product> GetAll()
{
    return _context.Products.ToList();
}

// ✅ ХОРОШО - async/await
public async Task<List<Product>> GetAllAsync()
{
    return await _context.Products.ToListAsync();
}
```

**Ошибка 5: Возврат Entity из API**
```csharp
// ❌ ПЛОХО - циклические ссылки, over-fetching
[HttpGet("{id}")]
public async Task<Product> Get(int id)
{
    return await _context.Products
        .Include(p => p.Category)
        .FirstAsync(p => p.Id == id);
}

// ✅ ХОРОШО - DTO
[HttpGet("{id}")]
public async Task<ProductDto> Get(int id)
{
    var product = await _context.Products
        .Include(p => p.Category)
        .FirstAsync(p => p.Id == id);
    
    return new ProductDto
    {
        Id = product.Id,
        Name = product.Name,
        Price = product.Price,
        CategoryName = product.Category.Name
    };
}
```

**Ошибка 6: Generic Repository**
```csharp
// ❌ АНТИПАТТЕРН
public interface IRepository<T> where T : class
{
    Task<IEnumerable<T>> GetAllAsync();
    Task<T> GetByIdAsync(int id);
    // ...
}

// ✅ ПРАВИЛЬНО - Specific Repository
public interface IProductRepository
{
    Task<Product?> GetByIdWithCategoryAsync(int id);
    Task<IEnumerable<Product>> GetActiveProductsAsync();
}
```

### 14.3 Performance Tips

```csharp
// ✅ Проекция полей (Select)
var products = await _context.Products
    .Select(p => new { p.Id, p.Name, p.Price })
    .ToListAsync();

// ✅ Пагинация
var products = await _context.Products
    .Skip((page - 1) * pageSize)
    .Take(pageSize)
    .ToListAsync();

// ✅ AsSplitQuery для множественных Include
var orders = await _context.Orders
    .Include(o => o.Items)
    .Include(o => o.Customer)
    .AsSplitQuery() // Разделить на несколько запросов
    .ToListAsync();

// ✅ Compiled Queries для часто используемых запросов
private static readonly Func<ApplicationDbContext, int, Task<Product?>> 
    GetProductById = EF.CompileAsyncQuery(
        (ApplicationDbContext context, int id) =>
            context.Products.FirstOrDefault(p => p.Id == id));
```

### 14.4 Чек-лист перед деплоем

- [ ] Connection strings в переменных окружения
- [ ] Миграции применяются автоматически
- [ ] Нет синхронных методов работы с БД
- [ ] AsNoTracking используется для read-only
- [ ] Sensitive data logging выключен в production
- [ ] DTO используются вместо Entity в API
- [ ] Сервисы зарегистрированы с правильным lifetime
- [ ] Логирование настроено
- [ ] Нет Generic Repository
- [ ] DbContext не используется в контроллерах

---

## 15. Резюме

### Что мы изучили

**Конфигурация (10 мин):**
- Система конфигурации ASP.NET Core
- Options Pattern для strongly-typed настроек
- Безопасное хранение секретов

**Dependency Injection (12 мин):**
- Времена жизни: Singleton, Scoped, Transient
- Регистрация и использование сервисов
- Типичные ошибки и best practices

**Архитектура (16 мин):**
- N-Layer: простой и понятный подход
- Clean Architecture: enterprise решение
- Dependency Rule и инверсия зависимостей

**Работа с данными (23 мин):**
- PostgreSQL в Docker
- EF Core: настройка, DbContext, связи
- DbContext Factory
- FluentMigrator: автоматические миграции

**Паттерны (18 мин):**
- Почему Generic Repository - антипаттерн
- Specific Repository для сложных запросов
- Unit of Work для транзакций
- Лучшие практики и типичные ошибки

### Ключевые выводы

1. **Используйте правильную архитектуру** с самого начала
2. **Generic Repository - антипаттерн**, используйте Specific
3. **DbContext уже является Repository и Unit of Work**
4. **Всегда async/await** для работы с БД
5. **AsNoTracking** для read-only операций
6. **Options Pattern** для конфигурации
7. **User Secrets** в dev, **Environment Variables** в prod
8. **FluentMigrator** для автоматических миграций

### Дополнительные материалы

- **Microsoft Docs:** https://learn.microsoft.com/en-us/aspnet/core/
- **Clean Architecture:** https://github.com/jasontaylordev/CleanArchitecture
- **EF Core Performance:** https://learn.microsoft.com/en-us/ef/core/performance/
- **FluentMigrator:** https://fluentmigrator.github.io/

---
