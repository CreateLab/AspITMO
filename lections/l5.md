# Лекция 4: Работа с файлами и real-time коммуникация

**Продолжительность:** 60 минут  
**Формат:** Теоретическая лекция с примерами кода

---

## 1. Работа с файлами в ASP.NET Core (30 минут)

### 1.1 Загрузка файлов: IFormFile (12 минут)

#### Интерфейс IFormFile
`IFormFile` — основной интерфейс для работы с загружаемыми файлами в ASP.NET Core.

**Ключевые свойства:**
```csharp
public interface IFormFile
{
    string ContentType { get; }        // MIME-тип (например, "image/jpeg")
    string ContentDisposition { get; } // Заголовок Content-Disposition
    string FileName { get; }           // Имя файла от клиента
    long Length { get; }               // Размер в байтах
    string Name { get; }               // Имя поля формы
    
    IHeaderDictionary Headers { get; } // HTTP заголовки
    
    // Методы для работы с содержимым
    Stream OpenReadStream();
    void CopyTo(Stream target);
    Task CopyToAsync(Stream target, CancellationToken cancellationToken);
}
```

#### Multipart/form-data
Для загрузки файлов используется кодирование `multipart/form-data`:
```csharp
// HTML форма должна иметь:
// <form method="post" enctype="multipart/form-data">

[HttpPost("upload")]
public async Task<IActionResult> UploadFile(IFormFile file)
{
    if (file == null || file.Length == 0)
        return BadRequest("Файл не выбран");
    
    // Получаем информацию о файле
    var fileName = file.FileName;           // "photo.jpg"
    var contentType = file.ContentType;     // "image/jpeg"
    var size = file.Length;                 // 1024567
    
    // Сохранение файла
    var path = Path.Combine("uploads", fileName);
    using (var stream = new FileStream(path, FileMode.Create))
    {
        await file.CopyToAsync(stream);
    }
    
    return Ok(new { fileName, size });
}
```

#### Множественная загрузка
```csharp
// Вариант 1: List<IFormFile>
[HttpPost("upload-multiple")]
public async Task<IActionResult> UploadMultiple(List<IFormFile> files)
{
    foreach (var file in files)
    {
        // Обработка каждого файла
    }
}

// Вариант 2: IFormFileCollection
[HttpPost("upload-collection")]
public async Task<IActionResult> UploadCollection(IFormFileCollection files)
{
    var uploadedFiles = new List<string>();
    
    foreach (var file in files)
    {
        uploadedFiles.Add(file.FileName);
    }
    
    return Ok(uploadedFiles);
}
```

#### Модель с файлами и данными
```csharp
public class FileUploadViewModel
{
    public string Title { get; set; }
    public string Description { get; set; }
    public IFormFile File { get; set; }
    public List<IFormFile> Attachments { get; set; }
}

[HttpPost("upload-with-data")]
public async Task<IActionResult> UploadWithData([FromForm] FileUploadViewModel model)
{
    // Доступ к данным формы и файлам
    var title = model.Title;
    var file = model.File;
    // ...
}
```

### 1.2 Скачивание файлов: FileResult (8 минут)

#### Базовый класс FileResult
`FileResult` — абстрактный базовый класс для возврата файлов:
```csharp
public abstract class FileResult : ActionResult
{
    public string ContentType { get; set; }
    public string FileDownloadName { get; set; }  // Имя для скачивания
    public DateTimeOffset? LastModified { get; set; }
    public EntityTagHeaderValue EntityTag { get; set; }
    public bool EnableRangeProcessing { get; set; } // Поддержка частичной загрузки
}
```

#### PhysicalFileResult
Возвращает файл из файловой системы:
```csharp
[HttpGet("download/{fileName}")]
public IActionResult DownloadFile(string fileName)
{
    var path = Path.Combine("uploads", fileName);
    
    if (!System.IO.File.Exists(path))
        return NotFound();
    
    // Вариант 1: Упрощенный синтаксис
    return PhysicalFile(path, "application/octet-stream", fileName);
    
    // Вариант 2: Полный контроль
    return new PhysicalFileResult(path, "application/pdf")
    {
        FileDownloadName = "document.pdf",
        EnableRangeProcessing = true  // Поддержка Resume
    };
}
```

#### FileContentResult
Возвращает содержимое из массива байтов:
```csharp
[HttpGet("generate-file")]
public IActionResult GenerateFile()
{
    var content = Encoding.UTF8.GetBytes("Hello, World!");
    
    return File(content, "text/plain", "hello.txt");
    // или
    return new FileContentResult(content, "text/plain")
    {
        FileDownloadName = "hello.txt"
    };
}
```

#### FileStreamResult
Возвращает файл из потока:
```csharp
[HttpGet("stream-file")]
public IActionResult StreamFile()
{
    var stream = new MemoryStream();
    // Заполнение потока данными
    stream.Position = 0;
    
    return File(stream, "application/octet-stream", "data.bin");
    // или
    return new FileStreamResult(stream, "application/pdf")
    {
        FileDownloadName = "report.pdf"
    };
}
```

#### VirtualFileResult
Возвращает файл из wwwroot:
```csharp
[HttpGet("static-file")]
public IActionResult GetStaticFile()
{
    return new VirtualFileResult("/files/document.pdf", "application/pdf")
    {
        FileDownloadName = "document.pdf"
    };
}
```

### 1.3 Streaming больших файлов (5 минут)

#### Проблема буферизации
При обычной загрузке весь файл загружается в память, что проблематично для больших файлов.

#### MultipartReader класс
```csharp
using Microsoft.AspNetCore.WebUtilities;

[HttpPost("stream-upload")]
[DisableFormValueModelBinding]  // Отключает автоматическую буферизацию
[RequestSizeLimit(500_000_000)] // 500 MB
public async Task<IActionResult> StreamUpload()
{
    var boundary = HeaderUtilities.RemoveQuotes(
        MediaTypeHeaderValue.Parse(Request.ContentType).Boundary
    ).Value;
    
    var reader = new MultipartReader(boundary, Request.Body);
    
    MultipartSection section;
    while ((section = await reader.ReadNextSectionAsync()) != null)
    {
        var hasContentDisposition = ContentDispositionHeaderValue.TryParse(
            section.ContentDisposition, out var contentDisposition);
        
        if (hasContentDisposition && contentDisposition.IsFileDisposition())
        {
            var fileName = contentDisposition.FileName.Value;
            
            // Streaming напрямую в файл
            var filePath = Path.Combine("uploads", fileName);
            using (var targetStream = System.IO.File.Create(filePath))
            {
                await section.Body.CopyToAsync(targetStream);
            }
        }
    }
    
    return Ok();
}
```

#### DisableFormValueModelBinding атрибут
```csharp
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class DisableFormValueModelBindingAttribute : Attribute, IResourceFilter
{
    public void OnResourceExecuting(ResourceExecutingContext context)
    {
        var factories = context.ValueProviderFactories;
        factories.RemoveType<FormValueProviderFactory>();
        factories.RemoveType<FormFileValueProviderFactory>();
        factories.RemoveType<JQueryFormValueProviderFactory>();
    }
    
    public void OnResourceExecuted(ResourceExecutedContext context) { }
}
```

### 1.4 Валидация файлов (5 минут)

#### Валидация размера

**RequestSizeLimitAttribute:**
```csharp
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class RequestSizeLimitAttribute : Attribute, IOrderedFilter
{
    public long Bytes { get; }
    
    public RequestSizeLimitAttribute(long bytes)
    {
        Bytes = bytes;
    }
}

// Использование
[RequestSizeLimit(10_485_760)] // 10 MB
public async Task<IActionResult> Upload(IFormFile file)
```

**Кастомный атрибут валидации:**
```csharp
public class MaxFileSizeAttribute : ValidationAttribute
{
    private readonly int _maxFileSize;
    
    public MaxFileSizeAttribute(int maxFileSize)
    {
        _maxFileSize = maxFileSize;
    }
    
    protected override ValidationResult IsValid(object value, ValidationContext context)
    {
        if (value is IFormFile file)
        {
            if (file.Length > _maxFileSize)
            {
                return new ValidationResult(
                    $"Максимальный размер файла {_maxFileSize} байт"
                );
            }
        }
        
        return ValidationResult.Success;
    }
}

// Использование
public class FileUploadModel
{
    [Required]
    [MaxFileSize(10 * 1024 * 1024)] // 10 MB
    public IFormFile File { get; set; }
}
```

#### Валидация типа файла

**File Signature (Magic Numbers):**
```csharp
public class FileSignatureValidator
{
    private static readonly Dictionary<string, List<byte[]>> _fileSignatures = 
        new Dictionary<string, List<byte[]>>
    {
        { ".jpg", new List<byte[]>
            {
                new byte[] { 0xFF, 0xD8, 0xFF, 0xE0 },
                new byte[] { 0xFF, 0xD8, 0xFF, 0xE2 },
                new byte[] { 0xFF, 0xD8, 0xFF, 0xE3 }
            }
        },
        { ".png", new List<byte[]>
            {
                new byte[] { 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A }
            }
        },
        { ".pdf", new List<byte[]>
            {
                new byte[] { 0x25, 0x50, 0x44, 0x46 }
            }
        },
        { ".zip", new List<byte[]>
            {
                new byte[] { 0x50, 0x4B, 0x03, 0x04 },
                new byte[] { 0x50, 0x4B, 0x05, 0x06 }
            }
        }
    };
    
    public static bool IsValidFileType(IFormFile file, string[] allowedExtensions)
    {
        var extension = Path.GetExtension(file.FileName).ToLowerInvariant();
        
        if (!allowedExtensions.Contains(extension))
            return false;
        
        if (!_fileSignatures.ContainsKey(extension))
            return true; // Нет сигнатуры для проверки
        
        using (var reader = new BinaryReader(file.OpenReadStream()))
        {
            var signatures = _fileSignatures[extension];
            var headerBytes = reader.ReadBytes(signatures.Max(m => m.Length));
            
            return signatures.Any(signature =>
                headerBytes.Take(signature.Length).SequenceEqual(signature)
            );
        }
    }
}
```

**AllowedExtensionsAttribute:**
```csharp
public class AllowedExtensionsAttribute : ValidationAttribute
{
    private readonly string[] _extensions;
    
    public AllowedExtensionsAttribute(string[] extensions)
    {
        _extensions = extensions;
    }
    
    protected override ValidationResult IsValid(object value, ValidationContext context)
    {
        if (value is IFormFile file)
        {
            var extension = Path.GetExtension(file.FileName);
            
            if (!_extensions.Contains(extension.ToLower()))
            {
                return new ValidationResult(
                    $"Разрешенные типы: {string.Join(", ", _extensions)}"
                );
            }
            
            // Проверка по сигнатуре
            if (!FileSignatureValidator.IsValidFileType(file, _extensions))
            {
                return new ValidationResult("Файл не соответствует заявленному типу");
            }
        }
        
        return ValidationResult.Success;
    }
}
```

---

## 2. Real-time коммуникация (30 минут)

### 2.1 WebSockets: основы (8 минут)

#### Что такое WebSocket
WebSocket — протокол полнодуплексной связи поверх TCP, обеспечивающий двустороннюю коммуникацию между клиентом и сервером.

**Отличия от HTTP:**
- Постоянное соединение (не request-response)
- Низкая задержка
- Меньше overhead (нет повторных заголовков)
- Двусторонняя передача данных

#### Класс WebSocket
```csharp
public sealed class WebSocket : IDisposable
{
    // Свойства
    public abstract WebSocketCloseStatus? CloseStatus { get; }
    public abstract string CloseStatusDescription { get; }
    public abstract WebSocketState State { get; }
    public abstract string SubProtocol { get; }
    
    // Методы отправки
    public abstract Task SendAsync(
        ArraySegment<byte> buffer,
        WebSocketMessageType messageType,
        bool endOfMessage,
        CancellationToken cancellationToken
    );
    
    // Методы получения
    public abstract Task<WebSocketReceiveResult> ReceiveAsync(
        ArraySegment<byte> buffer,
        CancellationToken cancellationToken
    );
    
    // Закрытие соединения
    public abstract Task CloseAsync(
        WebSocketCloseStatus closeStatus,
        string statusDescription,
        CancellationToken cancellationToken
    );
    
    public abstract Task CloseOutputAsync(
        WebSocketCloseStatus closeStatus,
        string statusDescription,
        CancellationToken cancellationToken
    );
}
```

#### WebSocketState enum
```csharp
public enum WebSocketState
{
    None = 0,           // Соединение еще не открыто
    Connecting = 1,     // Процесс подключения
    Open = 2,           // Соединение открыто
    CloseSent = 3,      // Отправлено сообщение о закрытии
    CloseReceived = 4,  // Получено сообщение о закрытии
    Closed = 5,         // Соединение закрыто
    Aborted = 6         // Соединение прервано
}
```

#### WebSocketReceiveResult класс
```csharp
public class WebSocketReceiveResult
{
    public int Count { get; }                          // Количество полученных байт
    public bool EndOfMessage { get; }                  // Конец сообщения?
    public WebSocketMessageType MessageType { get; }   // Тип сообщения
    public WebSocketCloseStatus? CloseStatus { get; }
    public string CloseStatusDescription { get; }
}

public enum WebSocketMessageType
{
    Text = 0,    // Текстовое сообщение (UTF-8)
    Binary = 1,  // Бинарное сообщение
    Close = 2    // Сообщение о закрытии
}
```

#### Настройка WebSocket middleware
```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// Настройка WebSocket
app.UseWebSockets(new WebSocketOptions
{
    KeepAliveInterval = TimeSpan.FromMinutes(2),  // Ping интервал
    ReceiveBufferSize = 4 * 1024                   // 4 KB буфер
});

// Обработка WebSocket запросов
app.Map("/ws", async context =>
{
    if (context.WebSockets.IsWebSocketRequest)
    {
        using var webSocket = await context.WebSockets.AcceptWebSocketAsync();
        await HandleWebSocketAsync(webSocket);
    }
    else
    {
        context.Response.StatusCode = 400;
    }
});

app.Run();
```

#### Пример обработки WebSocket соединения
```csharp
private static async Task HandleWebSocketAsync(WebSocket webSocket)
{
    var buffer = new byte[1024 * 4];
    
    // Цикл получения сообщений
    while (webSocket.State == WebSocketState.Open)
    {
        var result = await webSocket.ReceiveAsync(
            new ArraySegment<byte>(buffer),
            CancellationToken.None
        );
        
        if (result.MessageType == WebSocketMessageType.Close)
        {
            await webSocket.CloseAsync(
                WebSocketCloseStatus.NormalClosure,
                "Закрытие по запросу клиента",
                CancellationToken.None
            );
        }
        else
        {
            // Echo: отправляем обратно полученное сообщение
            await webSocket.SendAsync(
                new ArraySegment<byte>(buffer, 0, result.Count),
                result.MessageType,
                result.EndOfMessage,
                CancellationToken.None
            );
        }
    }
}
```

### 2.2 SignalR: архитектура и Hub (12 минут)

#### Что такое SignalR
SignalR — высокоуровневая библиотека для real-time коммуникации с автоматическим выбором транспорта:
1. WebSockets (приоритетный)
2. Server-Sent Events
3. Long Polling (fallback)

#### Базовый класс Hub
```csharp
public abstract class Hub : IDisposable
{
    // Контекст текущего подключения
    public HubCallerContext Context { get; set; }
    
    // Клиенты для отправки сообщений
    public IHubCallerClients Clients { get; set; }
    
    // Управление группами
    public IGroupManager Groups { get; set; }
    
    // Lifecycle методы
    public virtual Task OnConnectedAsync()
    {
        return Task.CompletedTask;
    }
    
    public virtual Task OnDisconnectedAsync(Exception exception)
    {
        return Task.CompletedTask;
    }
    
    // Освобождение ресурсов
    protected virtual void Dispose(bool disposing) { }
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
}
```

#### HubCallerContext класс
```csharp
public abstract class HubCallerContext
{
    // Уникальный ID подключения
    public abstract string ConnectionId { get; }
    
    // Authenticated пользователь
    public abstract ClaimsPrincipal User { get; }
    
    // Информация о пользователе
    public abstract string UserIdentifier { get; }
    
    // HTTP контекст
    public abstract HttpContext GetHttpContext();
    
    // Дополнительные данные
    public abstract IDictionary<object, object> Items { get; }
    
    // Токен отмены
    public abstract CancellationToken ConnectionAborted { get; }
    
    // Метаданные
    public abstract IFeatureCollection Features { get; }
}
```

#### IHubCallerClients интерфейс
```csharp
public interface IHubCallerClients
{
    // Всем клиентам
    IClientProxy All { get; }
    
    // Текущему клиенту (вызывающему)
    IClientProxy Caller { get; }
    
    // Всем кроме вызывающего
    IClientProxy Others { get; }
    
    // Всем кроме указанных
    IClientProxy AllExcept(IReadOnlyList<string> excludedConnectionIds);
    
    // Конкретному клиенту
    IClientProxy Client(string connectionId);
    
    // Нескольким клиентам
    IClientProxy Clients(IReadOnlyList<string> connectionIds);
    
    // Группе
    IClientProxy Group(string groupName);
    
    // Группе кроме вызывающего
    IClientProxy OthersInGroup(string groupName);
    
    // Группе кроме указанных
    IClientProxy GroupExcept(string groupName, IReadOnlyList<string> excludedConnectionIds);
    
    // Нескольким группам
    IClientProxy Groups(IReadOnlyList<string> groupNames);
    
    // Конкретному пользователю
    IClientProxy User(string userId);
    
    // Нескольким пользователям
    IClientProxy Users(IReadOnlyList<string> userIds);
}
```

#### IClientProxy интерфейс
```csharp
public interface IClientProxy
{
    // Вызов метода на клиенте
    Task SendCoreAsync(
        string method,
        object[] args,
        CancellationToken cancellationToken = default
    );
}

// Extension методы
public static class ClientProxyExtensions
{
    public static Task SendAsync(
        this IClientProxy clientProxy,
        string method,
        object arg1,
        CancellationToken cancellationToken = default
    )
    {
        return clientProxy.SendCoreAsync(method, new[] { arg1 }, cancellationToken);
    }
    
    // Перегрузки для разного количества аргументов...
}
```

#### IGroupManager интерфейс
```csharp
public interface IGroupManager
{
    // Добавить подключение в группу
    Task AddToGroupAsync(
        string connectionId,
        string groupName,
        CancellationToken cancellationToken = default
    );
    
    // Удалить подключение из группы
    Task RemoveFromGroupAsync(
        string connectionId,
        string groupName,
        CancellationToken cancellationToken = default
    );
}
```

#### Пример реализации Chat Hub
```csharp
public class ChatHub : Hub
{
    private readonly ILogger<ChatHub> _logger;
    private readonly IChatService _chatService;
    
    public ChatHub(ILogger<ChatHub> logger, IChatService chatService)
    {
        _logger = logger;
        _chatService = chatService;
    }
    
    // Подключение клиента
    public override async Task OnConnectedAsync()
    {
        var connectionId = Context.ConnectionId;
        var userId = Context.User?.Identity?.Name;
        
        _logger.LogInformation(
            "Client {ConnectionId} connected. User: {UserId}",
            connectionId, userId
        );
        
        // Уведомляем всех о новом пользователе
        await Clients.Others.SendAsync("UserConnected", connectionId, userId);
        
        // Отправляем историю сообщений новому пользователю
        var history = await _chatService.GetRecentMessagesAsync();
        await Clients.Caller.SendAsync("ReceiveHistory", history);
        
        await base.OnConnectedAsync();
    }
    
    // Отключение клиента
    public override async Task OnDisconnectedAsync(Exception exception)
    {
        var connectionId = Context.ConnectionId;
        var userId = Context.User?.Identity?.Name;
        
        _logger.LogInformation(
            "Client {ConnectionId} disconnected. User: {UserId}. Exception: {Exception}",
            connectionId, userId, exception?.Message
        );
        
        await Clients.Others.SendAsync("UserDisconnected", connectionId, userId);
        
        await base.OnDisconnectedAsync(exception);
    }
    
    // Отправка сообщения
    public async Task SendMessage(string user, string message)
    {
        // Валидация
        if (string.IsNullOrWhiteSpace(message))
            throw new HubException("Сообщение не может быть пустым");
        
        // Сохранение в БД
        var messageId = await _chatService.SaveMessageAsync(user, message);
        
        // Отправка всем клиентам
        await Clients.All.SendAsync("ReceiveMessage", user, message, messageId, DateTime.UtcNow);
    }
}
```

### 2.3 SignalR: Groups и Broadcasting (10 минут)

#### Работа с группами
```csharp
public class ChatRoomHub : Hub
{
    // Присоединиться к комнате
    public async Task JoinRoom(string roomName)
    {
        // Добавляем текущее подключение в группу
        await Groups.AddToGroupAsync(Context.ConnectionId, roomName);
        
        // Уведомляем участников комнаты
        await Clients.Group(roomName).SendAsync(
            "UserJoinedRoom",
            Context.User.Identity.Name,
            roomName
        );
        
        // Подтверждение вызывающему клиенту
        await Clients.Caller.SendAsync("JoinedRoom", roomName);
    }
    
    // Покинуть комнату
    public async Task LeaveRoom(string roomName)
    {
        await Groups.RemoveFromGroupAsync(Context.ConnectionId, roomName);
        
        await Clients.Group(roomName).SendAsync(
            "UserLeftRoom",
            Context.User.Identity.Name,
            roomName
        );
    }
    
    // Отправить сообщение в комнату
    public async Task SendToRoom(string roomName, string message)
    {
        var userName = Context.User.Identity.Name;
        
        // Отправка только участникам группы
        await Clients.Group(roomName).SendAsync(
            "ReceiveRoomMessage",
            roomName,
            userName,
            message,
            DateTime.UtcNow
        );
    }
    
    // Отправить сообщение в несколько комнат
    public async Task SendToMultipleRooms(List<string> roomNames, string message)
    {
        var userName = Context.User.Identity.Name;
        
        await Clients.Groups(roomNames).SendAsync(
            "ReceiveMessage",
            userName,
            message
        );
    }
    
    // Отправить всем в комнате кроме себя
    public async Task SendToOthersInRoom(string roomName, string message)
    {
        var userName = Context.User.Identity.Name;
        
        await Clients.OthersInGroup(roomName).SendAsync(
            "ReceiveMessage",
            userName,
            message
        );
    }
}
```

#### Broadcasting стратегии

**1. Broadcast всем:**
```csharp
public async Task BroadcastToAll(string message)
{
    await Clients.All.SendAsync("GlobalNotification", message);
}
```

**2. Broadcast всем кроме отправителя:**
```csharp
public async Task BroadcastToOthers(string message)
{
    var sender = Context.User.Identity.Name;
    await Clients.Others.SendAsync("Notification", sender, message);
}
```

**3. Broadcast конкретному пользователю (по User ID):**
```csharp
public async Task SendPrivateMessage(string targetUserId, string message)
{
    var sender = Context.User.Identity.Name;
    
    // Отправка конкретному пользователю (может иметь несколько подключений)
    await Clients.User(targetUserId).SendAsync(
        "ReceivePrivateMessage",
        sender,
        message
    );
    
    // Подтверждение отправителю
    await Clients.Caller.SendAsync("MessageSent", targetUserId);
}
```

**4. Broadcast конкретному подключению:**
```csharp
public async Task SendToConnection(string connectionId, string message)
{
    await Clients.Client(connectionId).SendAsync("DirectMessage", message);
}
```

**5. Broadcast нескольким подключениям:**
```csharp
public async Task SendToConnections(List<string> connectionIds, string message)
{
    await Clients.Clients(connectionIds).SendAsync("MulticastMessage", message);
}
```

#### Strongly-typed Hubs
```csharp
// Определяем интерфейс клиентских методов
public interface IChatClient
{
    Task ReceiveMessage(string user, string message);
    Task UserJoined(string user);
    Task UserLeft(string user);
    Task TypingStarted(string user);
    Task TypingStopped(string user);
}

// Используем generic Hub<T>
public class StronglyTypedChatHub : Hub<IChatClient>
{
    public async Task SendMessage(string user, string message)
    {
        // Компилятор проверяет существование метода и типы параметров
        await Clients.All.ReceiveMessage(user, message);
    }
    
    public async Task StartTyping()
    {
        var user = Context.User.Identity.Name;
        await Clients.Others.TypingStarted(user);
    }
    
    public async Task StopTyping()
    {
        var user = Context.User.Identity.Name;
        await Clients.Others.TypingStopped(user);
    }
    
    public override async Task OnConnectedAsync()
    {
        var user = Context.User.Identity.Name;
        await Clients.All.UserJoined(user);
        await base.OnConnectedAsync();
    }
    
    public override async Task OnDisconnectedAsync(Exception exception)
    {
        var user = Context.User.Identity.Name;
        await Clients.All.UserLeft(user);
        await base.OnDisconnectedAsync(exception);
    }
}
```

#### IHubContext для отправки извне Hub
```csharp
// Сервис для отправки уведомлений
public class NotificationService
{
    private readonly IHubContext<ChatHub> _hubContext;
    private readonly IHubContext<StronglyTypedChatHub, IChatClient> _typedHubContext;
    
    public NotificationService(
        IHubContext<ChatHub> hubContext,
        IHubContext<StronglyTypedChatHub, IChatClient> typedHubContext)
    {
        _hubContext = hubContext;
        _typedHubContext = typedHubContext;
    }
    
    // Отправка из фонового сервиса
    public async Task SendSystemNotification(string message)
    {
        await _hubContext.Clients.All.SendAsync("SystemNotification", message);
    }
    
    // Strongly-typed отправка
    public async Task NotifyUser(string userId, string message)
    {
        await _typedHubContext.Clients.User(userId)
            .ReceiveMessage("System", message);
    }
    
    // Отправка группе
    public async Task NotifyGroup(string groupName, string message)
    {
        await _hubContext.Clients.Group(groupName)
            .SendAsync("GroupNotification", message);
    }
}

// Использование в контроллере
[ApiController]
[Route("api/[controller]")]
public class NotificationsController : ControllerBase
{
    private readonly IHubContext<ChatHub> _hubContext;
    
    public NotificationsController(IHubContext<ChatHub> hubContext)
    {
        _hubContext = hubContext;
    }
    
    [HttpPost("broadcast")]
    public async Task<IActionResult> Broadcast([FromBody] string message)
    {
        await _hubContext.Clients.All.SendAsync("AdminBroadcast", message);
        return Ok();
    }
}
```

#### SignalR конфигурация в Program.cs
```csharp
var builder = WebApplication.CreateBuilder(args);

// Добавление SignalR с настройками
builder.Services.AddSignalR(options =>
{
    // Детальные ошибки (только для разработки)
    options.EnableDetailedErrors = true;
    
    // Интервал keep-alive (ping)
    options.KeepAliveInterval = TimeSpan.FromSeconds(15);
    
    // Таймаут клиента
    options.ClientTimeoutInterval = TimeSpan.FromSeconds(30);
    
    // Максимальный размер сообщения
    options.MaximumReceiveMessageSize = 128 * 1024; // 128 KB
    
    // Буферизация потоков
    options.StreamBufferCapacity = 10;
    
    // Интервал рукопожатия
    options.HandshakeTimeout = TimeSpan.FromSeconds(15);
    
    // Максимум параллельных вызовов
    options.MaximumParallelInvocationsPerClient = 1;
});

var app = builder.Build();

// Маппинг Hub endpoints
app.MapHub<ChatHub>("/chatHub");
app.MapHub<ChatRoomHub>("/chatRoomHub");
app.MapHub<StronglyTypedChatHub>("/typedChatHub");

app.Run();
```

---

## Резюме

### Ключевые классы для работы с файлами:
- **IFormFile** — интерфейс для загружаемых файлов
- **FileResult** — базовый класс для возврата файлов
- **PhysicalFileResult** — файлы из файловой системы
- **FileContentResult** — файлы из массива байтов
- **FileStreamResult** — файлы из потока
- **MultipartReader** — streaming загрузка больших файлов

### Ключевые классы для SignalR:
- **Hub** — базовый класс для real-time коммуникации
- **Hub<T>** — strongly-typed версия Hub
- **HubCallerContext** — контекст текущего подключения
- **IHubCallerClients** — интерфейс для отправки сообщений клиентам
- **IGroupManager** — управление группами
- **IHubContext<T>** — отправка сообщений извне Hub
- **WebSocket** — низкоуровневый класс для WebSocket соединений

### Best Practices:
1. Всегда валидируйте файлы по размеру и типу
2. Используйте streaming для файлов >5MB
3. Проверяйте file signature, а не только MIME-type
4. Генерируйте безопасные имена файлов
5. Используйте strongly-typed hubs для type safety
6. Обрабатывайте исключения в Hub методах
7. Логируйте подключения/отключения
8. Настраивайте timeouts в соответствии с требованиями
