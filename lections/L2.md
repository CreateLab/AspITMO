# Основы ASP.NET Core Web API: .NET 8 и .NET 9

## Введение

**Эта лекция представляет фундаментальные концепции разработки Web API на платформе ASP.NET Core**, охватывая актуальные версии .NET 8 и .NET 9. За 90 минут мы изучим теоретические основы RESTful архитектуры, структуру современных API проектов, механизмы Dependency Injection, маршрутизацию и документирование API. Фокус сделан на понимании **ПОЧЕМУ** и **КОГДА** использовать те или иные подходы, а не просто на синтаксисе кода. **Понимание этих концепций критично для создания масштабируемых, поддерживаемых и производительных веб-сервисов** в современной экосистеме .NET.

---

## 1. RESTful архитектура и принципы

### Что такое REST и почему это важно

REST (Representational State Transfer) — это **не протокол и не стандарт**, а архитектурный стиль для проектирования распределённых систем, созданный Роем Филдингом в 2000 году. REST определяет набор архитектурных ограничений, которые при совместном применении создают масштабируемые, поддерживаемые и эволюционируемые системы.

**Ключевое преимущество**: REST работает потому что использует существующую инфраструктуру HTTP, делая API интуитивно понятными и универсальными для любых платформ и языков программирования.

### Шесть архитектурных ограничений REST

**1. Разделение клиента и сервера (Client-Server)**

Разделение ответственности между клиентом (пользовательский интерфейс) и сервером (хранение данных, бизнес-логика) обеспечивает:
- **Портативность** UI на различных платформах
- **Масштабируемость** за счёт упрощения серверных компонентов
- **Независимую эволюцию** компонентов без влияния друг на друга

**2. Stateless (Без сохранения состояния)**

Каждый запрос от клиента к серверу должен содержать **ВСЮ информацию**, необходимую для понимания запроса. Сервер не хранит состояние между запросами.

**Почему это работает:**
- **Видимость** — мониторинговые системы понимают запрос без контекста предыдущих
- **Надёжность** — проще восстанавливаться от частичных сбоев
- **Масштабируемость** — сервер быстро освобождает ресурсы, не храня состояние

**Компромисс**: Увеличение сетевого трафика (повторяющиеся данные в каждом запросе) и снижение контроля сервера над поведением приложения.

**3. Cacheable (Кэшируемость)**

Ответы должны явно или неявно маркироваться как кэшируемые или некэшируемые. Это **частично или полностью устраняет взаимодействия клиент-сервер**, повышая эффективность и воспринимаемую пользователем производительность.

**4. Uniform Interface (Единообразный интерфейс)**

Центральная особенность REST. Применение универсальности к интерфейсу компонентов упрощает архитектуру системы и **делает реализации независимыми от предоставляемых сервисов**.

Четыре под-ограничения:
- **Идентификация ресурсов в запросах** — каждый ресурс идентифицируется URI
- **Манипуляция ресурсами через представления** — клиент имеет достаточно информации для изменения/удаления ресурса
- **Самоописываемые сообщения** — каждое сообщение содержит информацию о том, как его обрабатывать
- **HATEOAS** — переходы между состояниями приложения через выбор ссылок в представлениях

**5. Layered System (Слоистая система)**

Архитектура, состоящая из иерархических слоёв, где каждый компонент не "видит" дальше непосредственного слоя. Это позволяет внедрять промежуточные компоненты для балансировки нагрузки, кэширования и безопасности.

**6. Code-on-Demand (ОПЦИОНАЛЬНОЕ)**

Клиент может расширять функциональность, загружая и выполняя код (апплеты/скрипты). Единственное опциональное ограничение.

### HTTP методы: семантика и правильное использование

HTTP методы определяют **ЧТО делается** с ресурсом, в то время как URI определяет **С ЧЕМ** это делается.

**GET — Чтение ресурса**
- **Характеристики**: Безопасный (safe), идемпотентный, кэшируемый
- **Семантика**: Только чтение, НИКОГДА не изменяет состояние
- **Когда использовать**: Получение данных, списки, поиск
- **Пример**: `GET /api/products/5` — получить продукт с ID 5

**POST — Создание ресурса**
- **Характеристики**: НЕ безопасный, НЕ идемпотентный
- **Семантика**: Создаёт подчинённые ресурсы; сервер назначает идентификатор
- **Когда использовать**: Создание новых записей, сложные запросы
- **Ответ**: `201 Created` с заголовком `Location`
- **Теория**: Повторные POST создают множественные ресурсы

**PUT — Полная замена ресурса**
- **Характеристики**: НЕ безопасный, идемпотентный
- **Семантика**: Полная замена ВСЕХ свойств ресурса; клиент указывает идентификатор
- **Когда использовать**: Обновление всего объекта целиком
- **Теория**: Повторные PUT приводят к одинаковому состоянию

**PATCH — Частичное обновление**
- **Характеристики**: НЕ безопасный, не всегда идемпотентный
- **Семантика**: Применяет частичные изменения (delta), а не замену всего ресурса
- **Когда использовать**: Обновление отдельных полей без отправки всего объекта
- **Теория**: Введён RFC 5789 для эффективных частичных обновлений

**DELETE — Удаление ресурса**
- **Характеристики**: НЕ безопасный, идемпотентный
- **Семантика**: Удаляет ресурс
- **Теория**: Если вы удалили ресурс, он удалён; последующие DELETE не меняют состояние (идемпотентность)

### HTTP коды статуса: когда использовать

**Философия кодов статуса:** Коды адекватно описывают результат операции, создавая **единообразный контракт** между всеми API.

**2xx — Успех**
- **200 OK** — Стандартный успех (GET, PUT/PATCH с возвратом данных)
- **201 Created** — Ресурс создан (POST), включить заголовок `Location`
- **204 No Content** — Успех без тела ответа (DELETE, PUT без ответа)

**4xx — Ошибка клиента**
- **400 Bad Request** — Некорректный запрос, невалидные параметры, ошибки валидации
- **401 Unauthorized** — Требуется аутентификация (на самом деле "Unauthenticated")
- **403 Forbidden** — Аутентифицирован, но нет прав доступа (авторизация)
- **404 Not Found** — Ресурс не найден
- **409 Conflict** — Конфликт с текущим состоянием (дубликаты, конфликты версий)
- **422 Unprocessable Entity** — Валидный формат, но ошибки бизнес-логики

**5xx — Ошибка сервера**
- **500 Internal Server Error** — Неожиданная серверная ошибка
- **503 Service Unavailable** — Сервис временно недоступен (обслуживание, перегрузка)

**Критическое правило:** Используйте наиболее специфичный код. Не возвращайте 500 для всех ошибок и не возвращайте 200 для провальных операций.

### Best Practices проектирования RESTful API

**1. Используйте существительные, НЕ глаголы в URI**
- ✅ Правильно: `/api/users`, `/api/products/{id}`
- ❌ Неправильно: `/api/getUsers`, `/api/createProduct`
- **Теория**: URI идентифицируют ресурсы, HTTP методы указывают действия

**2. Множественное число для коллекций**
- ✅ `/api/customers`, `/api/orders`
- ❌ `/api/customer`, `/api/order`

**3. Иерархическая структура URI для связей**
- **Паттерн**: `/api/customers/{customerId}/orders/{orderId}`
- **Теория**: Показывает отношения между ресурсами

**4. Stateless — каждый запрос самодостаточен**
- Включайте все необходимые данные (токен авторизации, параметры)
- Используйте JWT вместо серверных сессий
- **Теория**: Stateless масштабируется лучше

**5. Версионирование API**
- URI: `/api/v1/users`
- Заголовки: `Accept: application/vnd.api+json;version=1`
- **Теория**: Позволяет эволюцию API без нарушения существующих клиентов

**6. Пагинация для коллекций**
```json
{
  "data": [...],
  "page": 1,
  "pageSize": 20,
  "totalCount": 150
}
```
**Теория**: Предотвращает проблемы производительности с большими наборами данных

---

## 2. Создание первого API проекта в .NET 8/9

### Структура проекта ASP.NET Core Web API

**Стандартная структура проекта:**

**Корневые файлы:**
- `Program.cs` — точка входа и конфигурация приложения
- `appsettings.json` — настройки конфигурации
- `appsettings.Development.json` — настройки для разработки
- `.csproj` — файл проекта (зависимости, настройки сборки)

**Папки:**
- `Controllers/` — классы контроллеров API
- `Models/` или `Entities/` — модели данных, DTOs
- `Services/` — бизнес-логика
- `Data/` — DbContext, доступ к данным

### Program.cs: Minimal Hosting Model в .NET 8/9

**Историческая эволюция:**
- **До .NET 6**: Требовалось два файла — `Program.cs` И `Startup.cs`
- **.NET 6+**: Единый файл `Program.cs` с top-level statements

**Философия:** Абстрагировать boilerplate код, сделать настройку интуитивной и читаемой.

### Как работает Minimal Hosting Model

**Два ключевых типа:**

**WebApplicationBuilder** (`builder`)
- Создаётся через `WebApplication.CreateBuilder(args)`
- Используется для конфигурации сервисов ПЕРЕД построением приложения
- **Ключевые свойства**:
  - `builder.Services` — контейнер Dependency Injection
  - `builder.Configuration` — доступ к конфигурации
  - `builder.Logging` — настройка логирования

**WebApplication** (`app`)
- Создаётся через `builder.Build()`
- Представляет сконфигурированное приложение
- Используется для конфигурации **middleware pipeline**
- **Ключевые методы**: `UseHttpsRedirection()`, `UseAuthorization()`, `MapControllers()`

### Типичная структура Program.cs

```csharp
// 1. СОЗДАНИЕ BUILDER
var builder = WebApplication.CreateBuilder(args);

// 2. КОНФИГУРАЦИЯ СЕРВИСОВ (Dependency Injection)
builder.Services.AddControllers();
builder.Services.AddDbContext<MyDbContext>();
builder.Services.AddScoped<IMyService, MyService>();

// 3. ПОСТРОЕНИЕ ПРИЛОЖЕНИЯ
var app = builder.Build();

// 4. КОНФИГУРАЦИЯ MIDDLEWARE PIPELINE
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

// 5. ЗАПУСК ПРИЛОЖЕНИЯ
app.Run();
```

**Что происходит под капотом:**

Когда вызывается `CreateBuilder()`:
1. Настраивается контейнер Dependency Injection
2. Конфигурируются провайдеры логирования (Console, Debug)
3. Загружается конфигурация из:
   - `appsettings.json`
   - `appsettings.{Environment}.json`
   - Переменных окружения
   - Аргументов командной строки
4. Настраивается веб-сервер Kestrel
5. Включается интеграция с IIS

### Middleware Pipeline — порядок имеет значение

Порядок регистрации middleware определяет **конвейер обработки запросов**:

```
Запрос → Exception Handler → HTTPS Redirect → Static Files → 
Routing → Authorization → Endpoints → Ответ
```

**Теория:** Каждый компонент middleware может:
- Обработать запрос
- Вызвать следующий middleware в конвейере
- Обработать ответ
- Прервать конвейер (short-circuit)

**Почему это важно:** Неправильный порядок может привести к тому, что авторизация не сработает или исключения не будут перехвачены.

---

## 3. Controllers и Actions

### Роль и назначение контроллеров

Контроллеры в ASP.NET Core Web API — это классы, наследующие `ControllerBase` (НЕ `Controller`, который для views). Они служат:
- **Обработчиками запросов** — принимают HTTP запросы, возвращают ответы
- **Контейнерами actions** — содержат методы, соответствующие endpoint'ам
- **Целями для DI** — получают сервисы через конструктор
- **Per-request экземплярами** — создаются и удаляются для каждого запроса

**ПОЧЕМУ ControllerBase, а не Controller?**
- `Controller` включает функциональность для views (ненужную для API)
- `ControllerBase` легче и оптимизирован для API сценариев

### Атрибут [ApiController] — возможности и преимущества

Атрибут `[ApiController]` включает специфичное для API поведение:

**1. Обязательная атрибутная маршрутизация**
- **ЧТО**: Делает attribute routing обязательным
- **ПОЧЕМУ**: Предоставляет явные, обнаруживаемые endpoint'ы

**2. Автоматические HTTP 400 ответы**
- **ЧТО**: Автоматически валидирует ModelState и возвращает 400 с ValidationProblemDetails
- **ПОЧЕМУ**: Устраняет повторяющиеся проверки `if (!ModelState.IsValid)`
- **Код, который больше НЕ нужен**:
```csharp
if (!ModelState.IsValid) {
    return BadRequest(ModelState);
}
```

**3. Автоматический вывод источников привязки параметров**
- **ЧТО**: Автоматически определяет откуда берутся параметры
- **ПОЧЕМУ**: Сокращает boilerplate код
- **Правила вывода**:
  - Сложные типы из DI → `[FromServices]`
  - Сложные типы не из DI → `[FromBody]`
  - Параметры из route template → `[FromRoute]`
  - Всё остальное → `[FromQuery]`

**4. ProblemDetails для ошибок**
- **ЧТО**: Возвращает RFC 7807-совместимый ProblemDetails для статусов 400+
- **ПОЧЕМУ**: Стандартизированный, машиночитаемый формат ошибок

**Критическое преимущество:** `[ApiController]` делает код чище, уменьшает количество ошибок валидации и обеспечивает единообразие API.

### ActionResult типы — когда использовать

**ActionResult<T> (РЕКОМЕНДУЕТСЯ)**
- **КОГДА**: Нужна гибкость + type safety + автоматическая документация
- **ПРЕИМУЩЕСТВА**:
  - Автоматический вывод типа для OpenAPI (не нужен `[ProducesResponseType]`)
  - Неявные преобразования из T или ActionResult
  - Проверка типов на этапе компиляции

```csharp
[HttpGet("{id}")]
public ActionResult<Product> GetById(int id)
{
    var product = _repository.GetById(id);
    if (product == null)
        return NotFound();
    return product; // Неявное преобразование!
}
```

**IActionResult**
- **КОГДА**: Множественные возможные типы возврата/статус коды
- **ТРЕБУЕТ**: `[ProducesResponseType]` для документации
- **Используйте**: Когда тип возврата может сильно варьироваться

**Конкретный тип (Product, List<Product>)**
- **КОГДА**: Единственный известный тип возврата без обработки ошибок
- **ОГРАНИЧЕНИЯ**: Нельзя вернуть разные статус коды

**Рекомендация:** Используйте `ActionResult<T>` по умолчанию — лучший баланс гибкости и типобезопасности.

### Общие ActionResult типы и когда их использовать

**Успешные ответы (2xx):**
- **Ok(value)** → 200: Стандартный успех с данными (GET, PUT/PATCH)
- **Created() / CreatedAtAction()** → 201: Ресурс создан (POST)
- **NoContent()** → 204: Успех без тела ответа (DELETE, PUT)

**Ошибки клиента (4xx):**
- **BadRequest(error)** → 400: Невалидный запрос, ошибки валидации
- **NotFound()** → 404: Ресурс не существует
- **Unauthorized()** → 401: Требуется аутентификация
- **Forbid()** → 403: Аутентифицирован, но не авторизован

**КОГДА использовать:**
- **200 OK**: GET, успешные PUT/PATCH с возвратом данных
- **201 Created**: POST создаёт новый ресурс
- **204 No Content**: DELETE, PUT/PATCH без ответа
- **400**: Невалидные данные, отсутствие обязательных полей
- **404**: GET/PUT/DELETE для несуществующего ID
- **422 Unprocessable Entity**: Валидный формат, но ошибки бизнес-логики

### HTTP атрибуты методов

**[HttpGet]** — Получение ресурсов
- **Характеристики**: Идемпотентный, кэшируемый, не должен изменять данные
- **КОГДА**: Чтение данных, списки, поиск
- **Параметры**: Из route/query string

**[HttpPost]** — Создание ресурсов
- **Характеристики**: НЕ идемпотентный, НЕ кэшируемый
- **КОГДА**: Создание новых ресурсов
- **Возврат**: 201 Created с заголовком Location

**[HttpPut]** — Полная замена ресурса
- **Характеристики**: Идемпотентный
- **КОГДА**: Замена всего ресурса целиком
- **Требует**: Полное представление ресурса

**[HttpPatch]** — Частичное обновление
- **КОГДА**: Обновление отдельных полей
- **Преимущество**: Не нужно отправлять весь объект

**[HttpDelete]** — Удаление ресурса
- **Характеристики**: Идемпотентный
- **Возврат**: 204 No Content или 200 с удалёнными данными

---

## 4. Dependency Injection

### Концепция и преимущества DI

Dependency Injection — это паттерн проектирования, реализующий Inversion of Control (IoC) между классами и их зависимостями. Вместо того чтобы класс создавал свои зависимости внутри, зависимости **предоставляются (инжектируются)** извне.

**Какие проблемы решает DI:**
- **Жёсткая связанность**: Без DI классы напрямую создают зависимости, создавая негибкий код
- **Сложности тестирования**: Невозможно легко подставить mock реализации
- **Разрастание конфигурации**: При изменении зависимости нужно модифицировать все зависимые классы
- **Нарушение единой ответственности**: Классы не должны создавать свои зависимости

**Ключевые преимущества:**
1. **Слабая связанность** — компоненты менее зависимы друг от друга
2. **Тестируемость** — зависимости могут быть замоканы при тестировании
3. **Поддерживаемость** — чёткое разделение ответственности
4. **Гибкость** — легко заменять реализации без изменения потребляющего кода
5. **Параллельная разработка** — команды работают над компонентами независимо

### Встроенный DI контейнер в ASP.NET Core

ASP.NET Core предоставляет встроенный DI контейнер, представленный `IServiceProvider`. Этот контейнер:
- Управляет временем жизни сервисов автоматически
- Разрешает зависимости через рефлексию
- Автоматически вызывает Dispose() для `IDisposable` экземпляров
- Поддерживает регистрацию через `IServiceCollection`

**Регистрация в Program.cs (.NET 8/9):**
```csharp
var builder = WebApplication.CreateBuilder(args);

// Регистрация сервисов
builder.Services.AddScoped<IMyDependency, MyDependency>();
builder.Services.AddSingleton<IConfiguration>();
builder.Services.AddTransient<IEmailService, EmailService>();
```

**Framework автоматически регистрирует 250+ сервисов**, включая:
- `ILogger<T>` и `ILoggerFactory` (Singleton)
- `IConfiguration` (Singleton)
- `IHttpContextAccessor` (Singleton)
- `DbContext` (Scoped по умолчанию)

### Время жизни сервисов: Transient, Scoped, Singleton

**Transient (AddTransient)**
- **Поведение**: **Новый экземпляр** создаётся **каждый раз** при запросе сервиса
- **Когда использовать**:
  - ✅ Сервис лёгкий и без состояния
  - ✅ Нет разделяемого состояния между вызовами
  - ✅ Не дорого создавать
- **Примеры**: Email отправители, валидаторы, formatters
- **Избегайте когда**: Сервис дорог в инициализации или реализует IDisposable

**Scoped (AddScoped) — Самый популярный для бизнес-логики**
- **Поведение**: **Один экземпляр на HTTP запрос**. Все сервисы в рамках одного запроса получают тот же экземпляр
- **Когда использовать**:
  - ✅ Сервис должен поддерживать состояние в рамках запроса
  - ✅ Работа с БД контекстами (Entity Framework `DbContext`)
  - ✅ Нужна консистентность состояния между операциями в запросе
  - ✅ Unit of Work паттерн
- **Примеры**: DbContext, репозитории, сервисы пользователя
- **КРИТИЧЕСКОЕ ПРАВИЛО**: **НИКОГДА не инжектируйте scoped сервисы в singleton** ("captive dependency")

**Singleton (AddSingleton)**
- **Поведение**: **Один экземпляр** на **всё время жизни приложения**. Один и тот же экземпляр используется всеми запросами и пользователями
- **Когда использовать**:
  - ✅ Сервис без состояния или с неизменяемым состоянием
  - ✅ Сервис дорог в создании
  - ✅ Нужно application-wide разделяемое состояние
  - ✅ Конфигурация и настройки
  - ✅ Кэш
- **Примеры**: IConfiguration, ILogger, кэши, менеджеры соединений
- **КРИТИЧЕСКИЕ ТРЕБОВАНИЯ**:
  - **ДОЛЖЕН быть потокобезопасным** (множественные потоки обращаются одновременно)
  - Не должен зависеть от scoped или transient сервисов

### Когда какое время жизни использовать: Decision Framework

**Задайте себе эти вопросы:**

1. **Сервис поддерживает состояние?**
   - Да, per-request → **Scoped**
   - Да, application-wide → **Singleton** (убедитесь в потокобезопасности)
   - Нет → **Transient или Singleton**

2. **Сервис дорог в создании?**
   - Да → **Singleton** (если без состояния) или **Scoped**
   - Нет → **Transient**

3. **Сервис работает с БД?**
   - Да (DbContext) → **Scoped**

4. **Сервис должен быть потокобезопасен?**
   - Да, реализован → **Singleton** возможен
   - Нет → **Scoped** или **Transient**

5. **Сервис реализует IDisposable?**
   - Да → Избегайте **Transient**, предпочтите **Scoped**

**Таблица быстрого выбора:**

| Тип сервиса | Время жизни | Причина |
|-------------|-------------|---------|
| DbContext | Scoped | Per-request unit of work |
| Repository | Scoped | Разделяет DbContext |
| Configuration | Singleton | Дорогая, неизменяемая |
| Logger | Singleton | Без состояния, разделяемая |
| Validators | Transient | Лёгкие, без состояния |
| Email Service | Transient | Без состояния |
| Cache | Singleton | Application-wide состояние |
| HttpClient | Singleton | Дорогой, переиспользуемый |
| Current User | Scoped | Per-request контекст |

### Constructor Injection — рекомендуемый паттерн

**Стандартная конструкторная инъекция (Рекомендуется):**
```csharp
public class OrderService
{
    private readonly IPaymentProcessor _paymentProcessor;
    private readonly ILogger<OrderService> _logger;
    
    public OrderService(
        IPaymentProcessor paymentProcessor,
        ILogger<OrderService> logger)
    {
        _paymentProcessor = paymentProcessor ?? 
            throw new ArgumentNullException(nameof(paymentProcessor));
        _logger = logger;
    }
}
```

**ПОЧЕМУ конструкторная инъекция предпочтительна:**
- Делает зависимости **явными и видимыми**
- Гарантирует доступность зависимостей при создании
- Обеспечивает **неизменяемость** (readonly поля)
- Упрощает **тестирование**
- Fail fast если зависимости отсутствуют

**Цепочки зависимостей:**
DI поддерживает цепочки зависимостей (зависимости, у которых есть свои зависимости):
```
Controller → Service → Repository → DbContext
```
Контейнер разрешает весь **граф зависимостей** автоматически.

### Типичные ошибки и антипаттерны

**1. CAPTIVE DEPENDENCY (Самая опасная)**
```csharp
// ❌ НЕПРАВИЛЬНО: Singleton захватывает Scoped сервис
public class Foo // Зарегистрирован как Singleton
{
    private readonly Bar _bar; // Bar — Scoped
    
    public Foo(Bar bar) // Bar "захватывается" на всё время жизни приложения
    {
        _bar = bar;
    }
}
```
**Почему это плохо:**
- Scoped сервис никогда не удаляется (memory leak)
- Scoped сервис ведёт себя как singleton (неправильное состояние)
- DbContext становятся устаревшими

**Решение**: Используйте `IServiceScopeFactory` для создания явного scope в singleton

**2. SERVICE LOCATOR АНТИПАТТЕРН**
```csharp
// ❌ НЕПРАВИЛЬНО: Ручное разрешение сервисов
public IActionResult Index()
{
    var service = HttpContext.RequestServices
        .GetService<IMyService>(); // Антипаттерн!
}
```
**Почему плохо:** Скрывает зависимости, усложняет тестирование

**Решение:** Используйте конструкторную инъекцию

**3. СЛИШКОМ МНОГО ЗАВИСИМОСТЕЙ (God Object)**
Если у класса 10+ параметров конструктора — это нарушение Single Responsibility Principle. Рефакторьте на более мелкие, сфокусированные классы.

### Keyed Services в .NET 8+ (Новинка)

**.NET 8 добавил возможность регистрировать и разрешать сервисы по ключам:**
```csharp
// Регистрация
builder.Services.AddKeyedSingleton<ICache, MemoryCache>("memory");
builder.Services.AddKeyedSingleton<ICache, RedisCache>("redis");

// Разрешение в конструкторе
public class CacheService(
    [FromKeyedServices("memory")] ICache memoryCache,
    [FromKeyedServices("redis")] ICache redisCache)
{
    // Используйте разные реализации по ключу
}
```

**Преимущества:**
- Множественные реализации одного интерфейса
- Поддержка паттерна Strategy
- Feature toggles и A/B тестирование

---

## 5. Routing и маршрутизация

### Attribute Routing vs Conventional Routing

**Attribute Routing (РЕКОМЕНДУЕТСЯ для API)**

**ЧТО:** Маршруты определяются напрямую на контроллерах/actions с помощью атрибутов

**ПОЧЕМУ использовать для API:**
- **Явность и обнаруживаемость** — маршруты видны там, где используются
- **Гибкость** — поддержка сложных паттернов
- **RESTful** — легко моделировать ресурсы
- **Обязательно** при использовании `[ApiController]`

```csharp
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    [HttpGet] // GET /api/products
    public IActionResult GetAll() { }
    
    [HttpGet("{id}")] // GET /api/products/5
    public IActionResult GetById(int id) { }
    
    [HttpGet("{id}/reviews")] // GET /api/products/5/reviews
    public IActionResult GetReviews(int id) { }
}
```

**Conventional Routing**

**КОГДА использовать:**
- MVC приложения с views
- Простые CRUD приложения с единообразной структурой
- Внутренние API

**ПОЧЕМУ НЕ для API:**
- Не работает с атрибутом `[ApiController]`
- Менее гибко для RESTful моделирования
- Сложнее версионировать

### Паттерны и ограничения маршрутов

**Токены замены:**
```csharp
[Route("api/[controller]")] // Заменяется именем контроллера
[Route("[controller]/[action]")] // Заменяется обоими
```

**Ограничения параметров:**
```csharp
[HttpGet("{id:int}")] // id должен быть integer
[HttpGet("{id:int:min(1)}")] // id должен быть >= 1
[HttpGet("{id:guid}")] // id должен быть GUID
[HttpGet("{slug:regex(^[a-z]+$)}")]  // Кастомное regex
```

**Опциональные параметры:**
```csharp
[HttpGet("{id?}")] // id опциональный
[HttpGet("search/{term=default}")] // term с дефолтным значением
```

**ВАЖНО:** Маршруты, начинающиеся с `/` или `~/`, НЕ комбинируются с маршрутом контроллера.

### Привязка параметров: FromRoute, FromQuery, FromBody

**[FromRoute] — Параметры из пути URL**
- **КОГДА**: Данные из сегментов пути URL
- **ПОЧЕМУ**: Для идентификации ресурсов (ID, slugs)
```csharp
[HttpGet("{id}")]
public IActionResult Get([FromRoute] int id) // /products/5
```

**[FromQuery] — Параметры из query string**
- **КОГДА**: Опциональные параметры поиска/фильтрации/пагинации
- **ПОЧЕМУ**: Для неидентифицирующих данных, модифицирующих результаты
```csharp
[HttpGet]
public IActionResult Search(
    [FromQuery] string term,
    [FromQuery] int page = 1,
    [FromQuery] int pageSize = 10)
// /products?term=laptop&page=2&pageSize=20
```
**ЛУЧШЕ ВСЕГО ДЛЯ**: Фильтрации, сортировки, пагинации, поиска

**[FromBody] — Данные из тела запроса**
- **КОГДА**: Сложные данные, отправляемые в теле запроса (обычно JSON)
- **ПОЧЕМУ**: Для создания/обновления ресурсов
```csharp
[HttpPost]
public IActionResult Create([FromBody] Product product)
```
**КРИТИЧЕСКОЕ ПРАВИЛО**: Только ОДИН параметр на action может использовать `[FromBody]`

**[FromHeader] — Данные из заголовков HTTP**
- **КОГДА**: Чтение кастомных или стандартных заголовков
- **ПОЧЕМУ**: Для метаданных, токенов авторизации, API ключей
```csharp
[HttpGet]
public IActionResult Get([FromHeader(Name = "X-API-Key")] string apiKey)
```

**[FromServices] — Из Dependency Injection**
- **КОГДА**: Инъекция сервисов в отдельные actions
- **ПОЧЕМУ**: Альтернатива конструкторной инъекции для action-специфичных сервисов

### Автоматический вывод источников привязки с [ApiController]

**С атрибутом [ApiController] (автоматический вывод):**
1. Зарегистрирован в DI? → `[FromServices]`
2. IFormFile/IFormFileCollection? → `[FromForm]`
3. Сложный тип? → `[FromBody]`
4. Имя совпадает с route template? → `[FromRoute]`
5. Всё остальное → `[FromQuery]`

**БЕЗ [ApiController]:** Должны явно указывать источник привязки для сложных типов.

### Best Practices маршрутизации

**DO (Делайте):**
- Используйте существительные, не глаголы: `/products`, не `/getProducts`
- Используйте HTTP методы для указания операций
- Держите маршруты простыми и предсказуемыми
- Множественное число для коллекций: `/products`, не `/product`
- Версионируйте API: `/api/v1/products`

**DON'T (Не делайте):**
- Не используйте имена action методов в маршрутах
- Не смешивайте attribute и conventional routing
- Не используйте зарезервированные слова: `action`, `controller`
- Не создавайте неоднозначные маршруты
- Не создавайте слишком глубокие иерархии (макс 2-3 уровня)

---

## 6. Swagger/OpenAPI

### Что такое OpenAPI и почему это важно

OpenAPI Specification (OAS) — это **языконезависимый стандарт** для документирования HTTP API. Он определяет структуру и синтаксис способом, не привязанным к конкретному языку программирования, позволяя как людям, так и компьютерам обнаруживать и понимать возможности API без доступа к исходному коду.

**Ключевые преимущества:**
1. **Стандартизация** — единый способ передачи информации на всех этапах жизненного цикла API
2. **Машиночитаемость** — автоматизированные инструменты для генерации кода, тестирования, документации
3. **Design-First подход** — команды могут спроектировать и согласовать API контракты до реализации
4. **Языковая независимость** — работает для всех языков и платформ

### Преимущества Swagger UI для разработки

Swagger UI предоставляет **интерактивный веб-интерфейс**, который:
1. **Встроенные тестовые возможности** — тестируйте endpoints прямо из браузера
2. **Функциональность "Try It Out"** — выполняйте реальные API вызовы с кастомными параметрами
3. **Визуализация запросов/ответов** — видите что отправляется и получается
4. **Живая документация** — всегда синхронизирована с кодом
5. **Минимальное кодирование и поддержка** — автоматические обновления при изменении кода

**Ценность для команд:**
- Product managers могут проверить, что API соответствует требованиям
- Frontend разработчики исследуют API до завершения backend
- Снижает недопонимание через ясные контракты

### Различия .NET 8 и .NET 9

**.NET 8 подход (Swashbuckle.AspNetCore):**
- Использует **сторонний пакет Swashbuckle** по умолчанию
- Включает Swagger UI из коробки
- Три основных компонента: Swagger, SwaggerGen, SwaggerUI
- Проверенный временем, стабильный

**.NET 9 подход (Microsoft.AspNetCore.OpenApi):**
- **Встроенная нативная поддержка OpenAPI** от Microsoft
- **Не включает UI** по умолчанию (добавляется отдельно)
- **ПОЧЕМУ изменение**: Проблемы с поддержкой Swashbuckle; Microsoft хочет first-class поддержку
- Лучший контроль, улучшенная безопасность, быстрые релизы
- Совместим с Native AOT
- Использует source generators для снижения overhead

**Важно**: Swashbuckle всё ещё полностью поддерживается в 2025 году и может быть вручную добавлен в .NET 9 проекты.

### Настройка в .NET 8 (Program.cs с Swashbuckle)

```csharp
using Microsoft.OpenApi.Models;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();

// Регистрация Swagger генератора
builder.Services.AddSwaggerGen(options =>
{
    options.SwaggerDoc("v1", new OpenApiInfo
    {
        Version = "v1",
        Title = "My API",
        Description = "ASP.NET Core Web API для управления элементами",
        Contact = new OpenApiContact
        {
            Name = "Контакт",
            Email = "contact@example.com"
        }
    });
    
    // Включение XML комментариев
    var xmlFilename = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
    options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, xmlFilename));
});

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger(); // JSON endpoint
    app.UseSwaggerUI(); // UI интерфейс
}

app.MapControllers();
app.Run();
```

**Доступ:**
- Swagger JSON: `https://localhost:<port>/swagger/v1/swagger.json`
- Swagger UI: `https://localhost:<port>/swagger`

### Настройка в .NET 9 (Program.cs с нативным OpenAPI)

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddOpenApi(); // Нативная поддержка OpenAPI

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.MapOpenApi(); // Экспонирует на /openapi/v1.json
}

app.Run();
```

**Добавление UI в .NET 9 (опционально):**

**Вариант 1: Scalar (современная альтернатива)**
```bash
dotnet add package Scalar.AspNetCore
```
```csharp
if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
    app.MapScalarApiReference(); // Доступно на /scalar/v1
}
```

**Вариант 2: Добавить Swashbuckle UI**
```bash
dotnet add package Swashbuckle.AspNetCore.SwaggerUI
```
```csharp
if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
    app.UseSwaggerUI(options =>
    {
        options.SwaggerEndpoint("/openapi/v1.json", "v1");
    });
}
```

### XML комментарии для документации

XML комментарии **критически важны для генерации комплексной документации API**. Они предоставляют:
1. Описания методов и endpoints
2. Документацию параметров с примерами
3. Документацию кодов ответа с объяснениями
4. Примеры запросов/ответов

**Включение в проекте:**

Редактируйте `.csproj` файл:
```xml
<PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn> <!-- Подавить предупреждения о отсутствующих комментариях -->
</PropertyGroup>
```

**Поддерживаемые теги:**
- `<summary>` — краткое описание метода
- `<remarks>` — дополнительная детальная информация
- `<param name="">` — описание параметра
- `<returns>` — что возвращает метод
- `<response code="">` — документация HTTP кодов ответа
- `<example>` — примеры кода

**Полный пример:**
```csharp
/// <summary>
/// Создаёт новый элемент TodoItem.
/// </summary>
/// <param name="item">TodoItem для создания</param>
/// <returns>Вновь созданный TodoItem</returns>
/// <remarks>
/// Пример запроса:
///
///     POST /Todo
///     {
///        "id": 1,
///        "name": "Задача #1",
///        "isComplete": true
///     }
///
/// </remarks>
/// <response code="201">Возвращает вновь созданный элемент</response>
/// <response code="400">Если элемент null</response>
[HttpPost]
[ProducesResponseType(StatusCodes.Status201Created)]
[ProducesResponseType(StatusCodes.Status400BadRequest)]
public async Task<IActionResult> Create(TodoItem item)
{
    _context.TodoItems.Add(item);
    await _context.SaveChangesAsync();
    return CreatedAtAction(nameof(Get), new { id = item.Id }, item);
}
```

**Улучшения .NET 9:**
- Автоматическая обработка через source generators на этапе компиляции
- Нет impact на runtime производительность
- Лучшая поддержка сложных типов

### Best Practices документирования API

**1. Всегда включайте XML документацию**
```xml
<GenerateDocumentationFile>true</GenerateDocumentationFile>
```

**2. Документируйте все публичные endpoints**
- Краткая summary (менее 50 символов)
- Объясните назначение и ограничения параметров
- Документируйте все возможные HTTP коды
- Предоставьте примеры запросов/ответов

**3. Используйте Data Annotations**
```csharp
public class TodoItem
{
    public long Id { get; set; }
    
    [Required]
    [StringLength(100, MinimumLength = 1)]
    public string Name { get; set; } = null!;
    
    [DefaultValue(false)]
    public bool IsComplete { get; set; }
}
```

**4. Явно документируйте типы ответов**
```csharp
[HttpGet("{id}")]
[ProducesResponseType(typeof(TodoItem), StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
public async Task<IActionResult> Get(int id) { }
```

**5. Документируйте требования безопасности**
Настройте документацию аутентификации (Bearer токены, API ключи) в SwaggerGen для ясности требований к аутентификации.

**6. Ограничьте Swagger Development окружением**
```csharp
if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
}
```
**Важная практика безопасности**: Никогда не экспонируйте OpenAPI документацию в production без авторизации.

### Интерактивное тестирование

**Возможности Swagger UI:**
1. **Try It Out** — активируйте для редактирования параметров и выполнения запросов
2. **Примеры Request Body** — предзаполненные примеры на основе моделей
3. **Визуализация ответов** — статус коды, заголовки, тела ответов
4. **Аутентификация** — настройка Bearer токенов, API ключей, OAuth2
5. **Визуализация схемы** — исследуйте модели данных и свойства

**Scalar UI (современная альтернатива для .NET 9):**
- Чистый современный интерфейс с dark mode
- Генерация кода на множестве языков (cURL, JavaScript, Python, C#)
- Улучшенный поиск
- Лучший UX для тестирования

**Интеграция с Postman:**
- Импорт OpenAPI JSON напрямую: File → Import → Link
- Вставьте URL OpenAPI endpoint: `https://localhost:<port>/openapi/v1.json`
- Postman автоматически генерирует всю коллекцию

---

## Современные best practices и типичные ошибки

### Архитектурные best practices

**1. Разделение ответственности**
- Разделите приложение на проекты (API, Core, Infrastructure, Tests)
- Контроллеры — только HTTP concerns
- Сервисы — бизнес-логика
- Репозитории — доступ к данным

**2. Используйте DTOs, не Entity модели**
- Никогда не экспонируйте сущности БД напрямую
- DTO для всех API входов/выходов
- Предотвращает circular reference проблемы
- Независимость API контракта от схемы БД

**3. Async всегда**
- Делайте весь call stack асинхронным
- Никогда не используйте `Task.Wait()` или `Task<T>.Result`
- Используйте async/await последовательно
- **ПОЧЕМУ**: Лучшая масштабируемость под нагрузкой

**4. Глобальная обработка ошибок**
- Используйте middleware `UseExceptionHandler`
- Реализуйте `IExceptionHandler` для кастомной обработки (.NET 8+)
- Логируйте все ошибки централизованно
- Возвращайте единообразные ответы ошибок (ProblemDetails RFC 7807)
- Никогда не экспонируйте stack traces в production

### Типичные ошибки, которых нужно избегать

**1. Блокировка асинхронных операций**
❌ НЕ ДЕЛАЙТЕ:
```csharp
var data = _repository.GetAllAsync().Result; // Блокирует!
```
✅ ДЕЛАЙТЕ:
```csharp
var data = await _repository.GetAllAsync();
```

**2. Неправильное использование HttpContext**
❌ НЕ ДЕЛАЙТЕ:
- Сохранять HttpContext в поле
- Обращаться к HttpContext из множественных потоков
- Использовать HttpContext после завершения запроса

**3. Service Locator антипаттерн**
❌ Не инжектируйте IServiceProvider напрямую
✅ Инжектируйте конкретные зависимости в конструктор

**4. Множественные [FromBody] параметры**
❌ НЕ ДЕЛАЙТЕ:
```csharp
public IActionResult Create([FromBody] Product product, [FromBody] User user) // ❌
```
✅ ДЕЛАЙТЕ:
```csharp
public IActionResult Create([FromBody] CreateRequest request) // ✓
```

**5. Отсутствие пагинации**
- Всегда реализуйте пагинацию для коллекций
- Никогда не возвращайте полные коллекции
- Предотвращает OutOfMemoryException и проблемы производительности

**6. Exposing Entity Models**
❌ Возврат сущностей БД напрямую
✅ Используйте DTOs для API контрактов

### Ключевые выводы для запоминания

**Концептуальные основы:**
1. **REST — архитектурный стиль**, не протокол; ограничения создают масштабируемость
2. **Stateless коммуникация** — каждый запрос самодостаточен
3. **HTTP методы определяют действие**, URI определяют ресурс
4. **Используйте правильные коды статуса** — они важны для семантики API

**Структура проекта:**
5. **Program.cs** — единый файл для конфигурации в .NET 8/9
6. **WebApplicationBuilder** → настраиваете сервисы → **Build()** → **WebApplication** → настраиваете middleware
7. **Порядок middleware критичен** — определяет конвейер обработки

**Controllers:**
8. **[ApiController]** обязателен — автоматическая валидация, вывод привязки, ProblemDetails
9. **ActionResult<T>** — лучший баланс type safety и гибкости
10. **Держите контроллеры тонкими** — только HTTP логика

**Dependency Injection:**
11. **Scoped для большинства** — особенно для DbContext и бизнес-сервисов
12. **Singleton** только для stateless или дорогих в создании
13. **Transient** для лёгких, stateless операций
14. **НИКОГДА не захватывайте scoped в singleton** — captive dependency антипаттерн

**Routing:**
15. **Attribute routing** для API — явный, гибкий, RESTful
16. **Существительные в URI**, методы HTTP для действий
17. **[FromBody]** для сложных типов, **[FromQuery]** для фильтров, **[FromRoute]** для ID

**Swagger/OpenAPI:**
18. **.NET 8** — Swashbuckle по умолчанию; **.NET 9** — нативный OpenAPI
19. **XML комментарии обязательны** — для комплексной документации
20. **Swagger только в Development** — безопасность в production

---

## Заключение

**ASP.NET Core Web API на платформе .NET 8/9 представляет собой мощную, современную экосистему** для построения веб-сервисов. Понимание теоретических основ — почему существуют ограничения REST, почему stateless важен, почему единообразные интерфейсы упрощают системы — критично для принятия информированных решений в проектировании.

Архитектурные ограничения REST не произвольные правила; они тщательно выбраны для оптимизации распределённых систем Internet-масштаба. Каждое ограничение (client-server, stateless, cacheable, layered system, uniform interface) индуцирует специфические свойства, делающие веб API масштабируемыми, поддерживаемыми и эволюционируемыми.

Minimal hosting model .NET 8/9 упрощает конфигурацию ASP.NET Core приложений, сохраняя полную мощь и гибкость. Консолидируя конфигурацию в единый Program.cs файл с top-level statements, Microsoft сократил boilerplate, сохранив enterprise-готовность платформы.

**Успех с RESTful API приходит от понимания не только КАК их реализовывать, но ПОЧЕМУ они работают именно так** — что позволяет принимать лучшие архитектурные решения и строить API, выдерживающие проверку временем.

### Дополнительные ресурсы для изучения

**Официальные источники:**
- Microsoft Learn: https://learn.microsoft.com/aspnet/core
- .NET Blog: https://devblogs.microsoft.com/dotnet
- GitHub ASP.NET Core: https://github.com/dotnet/aspnetcore
