# Вопросы по C# и ASP.NET Core Web API

## Лекция 1: Основы ASP.NET Core Web API

### RESTful архитектура и принципы

1. Объясните принцип Stateless в REST архитектуре. Почему серверу нельзя хранить состояние клиента между запросами? Как это влияет на масштабируемость и отказоустойчивость? Приведите примеры того, что можно и нельзя хранить на сервере.

2. Сравните идемпотентные и безопасные HTTP методы. Почему PUT идемпотентен, а POST нет? Приведите практические примеры ситуаций, когда эта разница критична для корректной работы API.

3. Объясните принцип HATEOAS (Hypermedia as the Engine of Application State). Почему многие современные API его не используют? Какие преимущества и недостатки несет следование этому принципу в реальных проектах?

4. Разберите разницу между кодами состояния 401 Unauthorized и 403 Forbidden. В каких конкретных сценариях нужно возвращать каждый из них? Почему важна эта разница для безопасности API?

5. Объясните концепцию Content Negotiation в REST API. Как клиент и сервер договариваются о формате данных? Какую роль играют заголовки Accept и Content-Type? Приведите пример, когда это критично.

6. Проанализируйте проблему использования глаголов в URL REST API (например, `/api/users/create`). Почему это считается нарушением принципов REST? Как правильно реализовать такие операции через HTTP методы и ресурсы?

7. Объясните разницу между кодами 404 Not Found и 410 Gone. В каких бизнес-сценариях важно использовать именно 410? Как это влияет на поведение клиентских приложений и кэширование?

8. Разберите концепцию ресурсо-ориентированного дизайна в REST. Как правильно моделировать сложные бизнес-операции через ресурсы? Приведите примеры хорошего и плохого дизайна URL для операций типа "перевод денег" или "отмена заказа".

9. Объясните, почему REST называется архитектурным стилем, а не протоколом. Какие ограничения (constraints) накладывает REST? Как эти ограничения влияют на разработку и могут ли они быть нарушены в реальных проектах?

10. Проанализируйте ситуацию: клиент отправил POST запрос на создание ресурса, но не получил ответ из-за таймаута. Как из-за не-идемпотентности POST это может привести к проблемам? Какие стратегии существуют для решения этой проблемы?

### Создание первого API проекта

11. Объясните концепцию Minimal Hosting Model, появившуюся в .NET 6. Какие проблемы со старым подходом (Startup.cs) она решает? Почему Microsoft решил отказаться от разделения на Startup и Program? Какие преимущества и недостатки у нового подхода?

12. Разберите роль Kestrel в ASP.NET Core. Почему это кросс-платформенный веб-сервер? В чем его отличия от IIS? Можно ли использовать ASP.NET Core полностью автономно без IIS, и в каких сценариях это имеет смысл?

13. Проанализируйте файл `launchSettings.json`. Какую роль он играет в разработке? Почему в нем несколько профилей? Объясните разницу между профилями и зачем нужны разные порты для разных окружений.

14. Объясните жизненный цикл ASP.NET Core приложения от вызова `WebApplication.CreateBuilder()` до `app.Run()`. Что происходит на каждом этапе? Почему важен порядок регистрации сервисов и middleware?

15. Разберите структуру типичного проекта Web API. Зачем нужны папки Controllers, Models, Services? Как правильно организовать код в больших проектах? Обоснуйте выбор той или иной структуры папок.

### Controllers, Actions, HTTP методы

16. Объясните роль атрибута `[ApiController]` в ASP.NET Core. Какие автоматические поведения он добавляет? Проанализируйте, почему автоматическая валидация ModelState и возврат 400 BadRequest полезны, но могут создавать проблемы в некоторых сценариях.

17. Сравните типы возвращаемых значений: `IActionResult`, `ActionResult<T>` и конкретный тип `T`. В каких ситуациях каждый из них предпочтителен? Как выбор влияет на документацию Swagger и type safety?

18. Разберите концепцию Model Binding в ASP.NET Core. Откуда framework может получать данные для параметров action методов? Объясните разницу между `[FromBody]`, `[FromQuery]`, `[FromRoute]`, `[FromHeader]` и `[FromForm]`. Почему нельзя иметь два параметра с `[FromBody]`?

19. Проанализируйте, почему использование `CreatedAtAction()` предпочтительнее простого `Created()` или `Ok()` при создании ресурсов. Как это связано с принципами REST? Что делает Location header в ответе и зачем он нужен клиенту?

20. Объясните проблему, когда в контроллере есть несколько action методов с одинаковым HTTP методом и маршрутом. Как ASP.NET Core выбирает нужный action? Какие стратегии существуют для разрешения таких конфликтов через маршруты и constraints?

21. Разберите концепцию content negotiation на уровне контроллера. Как один и тот же action может возвращать разные форматы (JSON, XML) в зависимости от заголовка Accept? Приведите реальные сценарии, когда это необходимо.

22. Проанализируйте использование status code helpers (`Ok()`, `BadRequest()`, `NotFound()` и т.д.). Почему важно возвращать правильные коды? Как неправильный код может сломать интеграцию с фронтенд-приложением или другими сервисами?

### Dependency Injection: основы и Program.cs

23. Объясните фундаментальную проблему tight coupling (сильной связанности), которую решает Dependency Injection. Приведите конкретный пример кода с и без DI. Как это влияет на тестируемость и поддерживаемость кода?

24. Разберите отношение между Dependency Injection и Inversion of Control. Это одно и то же или разные концепции? Какие еще способы реализации IoC существуют кроме DI? Почему в ASP.NET Core выбрали именно DI?

25. Объясните, почему изучение ASP.NET Core невозможно без понимания DI. Приведите примеры встроенных сервисов (DbContext, ILogger, IConfiguration), которые используют DI. Что произойдет, если попытаться создавать их вручную через `new`?

26. Проанализируйте концепцию constructor injection vs property injection vs method injection. Почему constructor injection считается best practice? В каких редких случаях допустимы другие виды injection?

27. Разберите жизненный цикл запроса в ASP.NET Core с точки зрения DI. Когда создается scope? Когда разрешаются зависимости? Когда вызывается Dispose для Scoped сервисов? Как это связано с HTTP запросом?

### Регистрация сервисов (AddScoped, AddTransient, AddSingleton)

28. Глубоко разберите концепцию Transient lifetime. Почему каждый раз создается новый экземпляр? В каких сценариях это оправдано (легковесные stateless сервисы)? Какие проблемы с производительностью могут возникнуть при неправильном использовании Transient?

29. Объясните Scoped lifetime в контексте HTTP запросов. Что такое "scope" физически в ASP.NET Core? Почему DbContext регистрируется как Scoped? Что произойдет с производительностью, если DbContext будет Transient или Singleton?

30. Проанализируйте опасности Singleton lifetime. Почему Singleton сервисы должны быть thread-safe? Приведите пример race condition при неправильной реализации Singleton. Когда Singleton действительно нужен (кэши, конфигурации)?

31. Разберите проблему "captive dependency". Что произойдет, если Singleton сервис внедряет Scoped зависимость? Почему это приведет к утечке памяти и некорректному поведению? Как ASP.NET Core пытается предотвратить эту проблему?

32. Объясните концепцию регистрации интерфейса с реализацией (`AddScoped<IService, ServiceImpl>()`). Зачем нужен интерфейс, если можно регистрировать конкретный класс? Как это связано с принципом Dependency Inversion (SOLID)?

33. Проанализируйте сценарий: нужно иметь несколько реализаций одного интерфейса (например, разные payment providers). Как зарегистрировать и использовать их все? Какие паттерны помогают выбирать нужную реализацию в runtime?

34. Разберите, что происходит при повторной регистрации одного сервиса. Какая регистрация победит: первая или последняя? Как это можно использовать для переопределения встроенных сервисов ASP.NET Core? Какие риски это несет?

### Routing и маршрутизация

35. Сравните attribute routing и conventional routing в ASP.NET Core. Почему в Web API предпочтительнее attribute routing? В каких сценариях conventional routing имеет смысл? Как выбор влияет на читаемость кода и поддержку?

36. Разберите работу токена `[controller]` в маршруте `[Route("api/[controller]")]`. Как ASP.NET Core преобразует имя класса в часть URL? Почему это может быть проблемой при рефакторинге (переименовании контроллера)?

37. Объясните механизм комбинирования маршрутов контроллера и action. Как работает наследование маршрутов? Приведите примеры корректного и некорректного комбинирования. Когда использовать `~` для отмены наследования маршрута?

38. Проанализируйте route constraints в деталях. Как constraint `{id:int}` влияет на выбор action? Что произойдет, если в URL будет не число? Как создать кастомные constraints для сложной валидации параметров маршрута?

39. Разберите разницу между параметрами маршрута и query string. Когда использовать каждый подход? Как это связано с RESTful принципами? Приведите примеры плохого дизайна API, где параметры используются неправильно.

40. Объясните опциональные параметры маршрута (`{id?}`). Как это работает с перегрузкой action методов? Какие проблемы могут возникнуть с ambiguous routes? Как ASP.NET Core разрешает конфликты между маршрутами?

### Swagger/OpenAPI: установка, настройка, XML комментарии

41. Разберите отношение между OpenAPI спецификацией и Swagger. Что такое OpenAPI Specification (OAS)? Почему это industry standard? Какие инструменты входят в Swagger ecosystem (Swagger UI, Swagger Editor, Swagger Codegen)?

42. Объясните роль Swagger в жизненном цикле API разработки. Как Swagger помогает в documentation, testing, и contract-first development? Почему автоматически генерируемая документация лучше, чем написанная вручную?

43. Проанализируйте процесс генерации OpenAPI документа из ASP.NET Core кода. Что происходит в `AddSwaggerGen()`? Как Swagger анализирует контроллеры, действия и модели? Какие атрибуты влияют на генерируемый документ?

44. Разберите включение XML комментариев в Swagger. Почему нужен отдельный файл XML документации? Как настроить проект для генерации XML файла? Какие теги (`<summary>`, `<param>`, `<response>`) и как влияют на Swagger UI?

45. Объясните концепцию схем (schemas) в OpenAPI. Как Swagger генерирует схемы для DTO классов? Как настроить отображение свойств, required полей, примеров значений? Что такое `$ref` в OpenAPI документе?

46. Проанализируйте документирование возможных HTTP ответов через атрибут `[ProducesResponseType]`. Зачем это нужно, если метод возвращает `ActionResult<T>`? Как это влияет на генерацию клиентского кода? Как документировать разные типы ошибок?

47. Разберите кастомизацию Swagger UI. Как изменить заголовок, описание API, добавить информацию о лицензии и контактах? Как группировать endpoints по тегам? Зачем нужны multiple Swagger documents для одного API?

---

## Лекция 2: Архитектура, конфигурация и работа с данными

### Configuration: appsettings.json, environment variables, Options pattern

48. Объясните концепцию hierarchical configuration в .NET. Как работает система конфигурации с multiple sources (appsettings.json, переменные окружения, command-line args)? Какой порядок приоритета? Зачем нужна такая сложность?

49. Разберите environment-specific configuration. Как работает `appsettings.Development.json` vs `appsettings.Production.json`? Что определяет текущий environment? Как это связано с переменной `ASPNETCORE_ENVIRONMENT`? Какие best practices для разных окружений?

50. Проанализируйте переопределение настроек через environment variables. Почему используется двойное подчеркивание (`__`) вместо точки для вложенных секций? Как это работает в разных OS (Windows, Linux)? Какие проблемы могут возникнуть?

51. Объясните Options Pattern в деталях. Какие проблемы решает этот паттерн по сравнению с прямым чтением `IConfiguration`? Как работает binding между JSON и C# классом? Что такое type-safe configuration?

52. Разберите разницу между `IOptions<T>`, `IOptionsSnapshot<T>` и `IOptionsMonitor<T>`. Когда значения перечитываются? Какой overhead у каждого подхода? В каких сценариях использовать каждый интерфейс?

53. Проанализируйте User Secrets для локальной разработки. Где физически хранятся секреты? Почему они не должны попадать в Git? Как это работает в команде разработчиков? Какие альтернативы существуют для CI/CD?

54. Объясните проблему конфигурации в микросервисной архитектуре. Как централизованно управлять настройками для десятков сервисов? Что такое Configuration Server? Как реализовать динамическую перезагрузку конфигурации без перезапуска приложения?

### Connection strings и безопасное хранение секретов

55. Разберите анатомию connection string для PostgreSQL. Что означает каждый параметр (Server, Port, Database, User Id, Password)? Как работают дополнительные параметры (Timeout, Pooling, SSL Mode)? Почему порядок параметров не важен?

56. Объясните концепцию connection pooling. Зачем переиспользовать соединения вместо создания новых? Как работает пул соединений? Что означают параметры Min Pool Size и Max Pool Size? Какие проблемы возникают при неправильной настройке пула?

57. Проанализируйте проблемы безопасности при хранении connection strings. Почему нельзя коммитить пароли в Git? Что может произойти при утечке connection string? Какие реальные инциденты были связаны с этой проблемой?

58. Разберите стратегии безопасного хранения секретов. User Secrets для development, переменные окружения для staging, Key Vaults (Azure Key Vault, AWS Secrets Manager) для production. Как выбрать подходящий подход? Какие trade-offs?

59. Объясните концепцию Managed Identity в облачных платформах. Как приложение может подключаться к базе данных вообще без пароля? Что такое service principal? Какие преимущества и ограничения у этого подхода?

60. Проанализируйте проблему ротации секретов. Как безопасно менять пароль базы данных в production? Как обеспечить zero-downtime при смене credentials? Что такое dual-running period для credentials?

### N-Layer Architecture: Presentation, Business Logic, Data Access

61. Объясните принцип Separation of Concerns на примере N-Layer архитектуры. Почему важно разделять код по слоям? Что происходит в проектах, где вся логика в контроллерах? Приведите реальный пример технического долга из-за отсутствия слоев.

62. Разберите ответственности каждого слоя в N-Layer. Что должно быть в Presentation (только HTTP-специфичные вещи или больше)? Куда помещать валидацию? Где место для бизнес-правил? Какие типичные ошибки в распределении ответственностей?

63. Проанализируйте направление зависимостей в N-Layer. Почему Presentation зависит от Business Logic, а Business Logic от Data Access? Что плохого в обратных зависимостях? Как это влияет на тестирование?

64. Объясните разницу между logical layers и physical tiers. Можно ли все слои держать в одном проекте или нужны отдельные assembly? Какие преимущества и недостатки разделения на проекты? Как выбрать правильную гранулярность?

65. Разберите проблему database-centric design в N-Layer архитектуре. Почему бизнес-логика часто становится anemic (анемичной)? Что такое transaction script anti-pattern? Как это приводит к дублированию логики?

66. Проанализируйте недостатки классической N-Layer архитектуры. Почему она может привести к tight coupling с инфраструктурой? Как изменение базы данных может потребовать изменений во всех слоях? Когда N-Layer не подходит?

67. Объясните, как организовать проекты для N-Layer в Visual Studio/Rider. Какие naming conventions использовать? Куда помещать общие типы (DTOs, Exceptions)? Как настроить project references, чтобы предотвратить circular dependencies?

### Clean Architecture: принципы, слои, dependency rule

68. Объясните фундаментальное Dependency Rule в Clean Architecture. Почему зависимости должны идти только внутрь, к ядру? Как это отличается от N-Layer? Приведите конкретный пример нарушения этого правила и его последствий.

69. Разберите концепцию Domain Layer (Core) в Clean Architecture. Что такое domain entities и чем они отличаются от database entities? Почему бизнес-правила должны быть в домене? Как достичь framework independence?

70. Проанализируйте Application Layer (Use Cases). Что такое use case и чем он отличается от сервиса в N-Layer? Как организовать команды (Commands) и запросы (Queries)? Что такое CQRS и связь с Clean Architecture?

71. Объясните роль интерфейсов (Ports) в Clean Architecture. Как Domain определяет интерфейсы репозиториев, не зная о базе данных? Что такое Dependency Inversion Principle в контексте этой архитектуры? Как это влияет на тестируемость?

72. Разберите Infrastructure Layer и его место в архитектуре. Почему реализации репозиториев, EF Core контекст, внешние API клиенты находятся здесь? Как Infrastructure зависит от Domain, но не наоборот? Какие проблемы это создает при разработке?

73. Проанализируйте trade-offs Clean Architecture. Когда эта архитектура оправдана (большие, долгоживущие проекты)? Когда она избыточна (простые CRUD API)? Какой overhead в разработке и обучении команды? Как измерить, что сложность оправдана?

74. Объясните тестирование в Clean Architecture. Почему unit-тесты бизнес-логики не требуют базы данных? Как использовать mocks для интерфейсов? Что такое testing pyramid и как Clean Architecture его поддерживает?

### Настройка EF Core и подключение к БД, регистрация DbContext через DI

75. Объясните концепцию ORM (Object-Relational Mapping). Какую проблему impedance mismatch между объектной и реляционной моделями решают ORM? Приведите примеры, где ORM упрощает работу, и где создает проблемы.

76. Разберите преимущества и недостатки Entity Framework Core. Когда стоит использовать EF Core, а когда лучше Dapper или даже raw SQL? Какой performance overhead у EF Core? Как это влияет на выбор для high-load систем?

77. Проанализируйте роль DbContext в EF Core. Почему это Unit of Work и Identity Map одновременно? Что такое change tracking и как это работает? Какой memory overhead от tracking? Когда его стоит отключать (`AsNoTracking()`)?

78. Объясните, почему DbContext регистрируется как Scoped, а не Transient или Singleton. Что произойдет с concurrent запросами при Singleton? Какие проблемы с производительностью при Transient? Как scope связан с database transactions?

79. Разберите настройку DbContext через `DbContextOptions`. Как передать connection string? Что такое `DbContextOptionsBuilder`? Как настроить logging, retry policies, command timeout через options? Можно ли иметь разные настройки для разных environments?

80. Проанализируйте метод `OnModelCreating()` в DbContext. Зачем нужен Fluent API, если есть Data Annotations? Какие настройки можно сделать только через Fluent API? Как организовать конфигурацию для десятков entities (Entity Configurations)?

81. Объясните разницу между DbSet и IQueryable. Когда запрос выполняется: при создании IQueryable или при итерации? Что такое deferred execution? Как это влияет на производительность и N+1 проблему?

### DbContext, миграции, связи между сущностями

82. Объясните концепцию миграций в EF Core. Почему code-first подход предпочтительнее database-first для большинства проектов? Как миграции связаны с version control? Что происходит с базой данных при работе в команде?

83. Разберите альтернативу EF миграциям - FluentMigrator. Какие преимущества у code-based миграций без привязки к ORM? Когда FluentMigrator предпочтительнее? Как организовать миграции в микросервисной архитектуре?

84. Проанализируйте проблему откатов (rollback) миграций. Как безопасно откатить изменения в production? Что такое up/down методы? Какие операции нельзя откатить (например, удаление столбца с данными)? Какие стратегии для безопасных изменений схемы?

85. Объясните концепцию навигационных свойств (navigation properties) в EF Core. Как EF понимает связи между entities по соглашению? Что такое principal и dependent entities? Как настроить связи явно через Fluent API?

86. Разберите one-to-many relationship в деталях. Как работает foreign key? Что такое cascade delete и когда его использовать? Какие проблемы создает cascade delete (случайное удаление данных)? Как реализовать soft delete?

87. Проанализируйте many-to-many relationship в EF Core 5+. Как EF автоматически создает join table? Когда нужна явная join entity с дополнительными полями? Как запрашивать данные через many-to-many? Какие performance проблемы могут возникнуть?

88. Объясните концепцию eager loading, lazy loading и explicit loading. В чем разница между `.Include()`, navigation property access, и `.Load()`? Что такое N+1 проблема и как её избежать? Какие trade-offs у каждого подхода?

89. Разберите owned entities и value objects в EF Core. Чем owned entity отличается от обычной? Как хранить value objects (например, Address) в той же таблице? Что такое table splitting? Когда использовать owned entities вместо отдельных таблиц?

### Repository и Unit of Work паттерны

90. Объясните, почему Generic Repository считается anti-pattern при использовании с EF Core. Как Generic Repository дублирует функциональность DbContext? Что такое принцип YAGNI и почему Generic Repository его нарушает? Приведите примеры абстракций ради абстракций.

91. Разберите конкретные проблемы Generic Repository. Как он усложняет сложные запросы (joins, filtering, projections)? Почему приходится добавлять методы типа `GetWithIncludes()`, `GetFiltered()`? Как это приводит к "leaky abstraction"?

92. Проанализируйте, когда Specific Repository действительно нужен. Приведите примеры сложной, переиспользуемой query logic (например, "получить активные заказы пользователя с деталями"). Как инкапсуляция такой логики в Repository улучшает код? Когда достаточно просто использовать DbContext?

93. Объясните, почему DbContext уже реализует Unit of Work pattern. Что такое Unit of Work? Как `SaveChanges()` работает как transaction boundary? Зачем создавать дополнительный класс UnitOfWork, если есть DbContext?

94. Разберите сценарий, когда дополнительный Unit of Work класс оправдан: координация нескольких DbContext, работа с разными базами данных, транзакции через несколько bounded contexts. Как реализовать распределенные транзакции?

95. Проанализируйте change tracking в EF Core как реализацию Identity Map pattern. Как EF отслеживает изменения entities? Что происходит в памяти между Load и SaveChanges? Какой overhead от tracking и когда его стоит отключить?

96. Объясните explicit transactions в EF Core. Когда нужен `BeginTransaction()` вместо полагаться на `SaveChanges()`? Как работать с несколькими SaveChanges в одной транзакции? Что такое transaction isolation levels и как их настроить?

---

## Лекция 3: Аутентификация и авторизация в API

### JWT токены: структура и принцип работы

97. Разберите структуру JWT токена (header.payload.signature). Что содержит каждая часть? Как работает Base64Url encoding? Почему токен не зашифрован, но безопасен? Как любой может прочитать payload, но не может подделать токен?

98. Объясните процесс генерации и верификации подписи JWT. Как работает HMAC (HS256) алгоритм? Почему важна длина секретного ключа? Что произойдет, если использовать короткий ключ? Как brute-force атаки связаны с длиной ключа?

99. Проанализируйте разницу между симметричными (HS256) и асимметричными (RS256) алгоритмами подписи. Когда использовать каждый? Как работает public/private key в RS256? Какие преимущества для микросервисов?

100. Разберите claims в JWT. Какие стандартные claims (sub, exp, iat, iss, aud) и зачем они нужны? Как добавлять кастомные claims (user roles, permissions)? Какие ограничения на размер токена из-за claims?

101. Объясните концепцию stateless authentication. Почему JWT не требует хранения сессий на сервере? Как это влияет на масштабируемость? Какие проблемы создает невозможность отозвать токен до истечения срока?

102. Проанализируйте security trade-offs JWT. Почему нельзя хранить sensitive data в JWT? Что такое XSS и как украсть JWT через JavaScript? Где безопасно хранить токены: localStorage, sessionStorage, или httpOnly cookies?

103. Разберите проблему token expiration. Почему короткий срок жизни (15-30 минут) для access token? Что делать при истечении токена: заставить пользователя логиниться снова или использовать refresh token? Какие UX последствия?

### Реализация регистрации и логина

104. Объясните разницу между authentication (аутентификацией) и authorization (авторизацией). Почему это часто путают? Приведите примеры: можно ли быть аутентифицированным, но не авторизованным? Как это работает в реальных системах (например, заблокированный пользователь)?

105. Разберите процесс безопасного хранения паролей. Почему категорически нельзя хранить пароли в открытом виде или даже зашифрованными? Что такое хеширование и чем оно отличается от шифрования? Почему хеши "односторонние"?

106. Проанализируйте роль salt в хешировании паролей. Как rainbow tables атакуют хеши без salt? Почему salt должен быть уникальным для каждого пользователя? Где хранить salt: отдельно или вместе с хешем?

107. Объясните, почему современные password hashing алгоритмы (bcrypt, Argon2) медленные специально. Что такое cost factor? Как это защищает от brute-force? Какие проблемы создает для легитимных пользователей при логине?

108. Разберите flow регистрации пользователя. Какие данные валидировать? Как проверять уникальность email/username? Что делать при попытке регистрации существующего email: возвращать ошибку или "успешно зарегистрирован" (для безопасности)? Как это связано с user enumeration атаками?

109. Проанализируйте flow логина и генерации JWT. Как безопасно сравнивать хеши? Почему timing attacks опасны? Что возвращать при неверном пароле: "неверный пароль" или "неверный email или пароль"? Как защититься от brute-force логинов (rate limiting, CAPTCHA)?

110. Объясните проблему хранения секретного ключа для JWT. Где хранить ключ: в коде, appsettings.json, переменных окружения, Key Vault? Что произойдет, если ключ утечет? Как безопасно ротировать ключи в production?

### Настройка JWT в Swagger и Middleware для проверки токенов

111. Объясните настройку JWT authentication в Swagger UI. Зачем нужна кнопка Authorize? Как это улучшает developer experience? Что происходит под капотом при вводе токена: как Swagger добавляет его к каждому запросу?

112. Разберите концепцию middleware pipeline в ASP.NET Core. Как middleware образует цепочку? Почему порядок middleware критически важен? Что произойдет, если `UseAuthentication()` будет после `UseAuthorization()`?

113. Проанализируйте работу authentication middleware. Что делает `UseAuthentication()`? Как middleware читает JWT из заголовка Authorization? Как парсится и валидируется токен? Что происходит с ClaimsPrincipal?

114. Объясните настройку JWT Bearer authentication в Program.cs. Что такое authentication scheme? Зачем указывать DefaultAuthenticateScheme и DefaultChallengeScheme? Что происходит при multiple authentication schemes?

115. Разберите TokenValidationParameters в деталях. Почему нужно валидировать Issuer и Audience, а не только подпись? Что такое ValidateLifetime и как работает clock skew? Какие security риски при отключении валидаций?

116. Проанализируйте, что происходит при невалидном или отсутствующем токене. Какой HTTP status code возвращается (401 vs 403)? Как настроить кастомные ответы? Что такое challenge и forbid в authentication?

117. Объясните, как получить данные текущего пользователя в контроллере. Что такое HttpContext.User? Как достать claims из ClaimsPrincipal? Почему нельзя доверять клиентским данным и нужно полагаться на токен?

### Role-based и Claims-based авторизация, Refresh tokens

118. Сравните role-based и claims-based авторизацию. Когда достаточно ролей (Admin, User)? Когда нужны более гранулированные claims (CanEditPosts, CanDeleteComments)? Как это масштабируется в больших системах?

119. Разберите проблемы с role-based подходом. Что происходит, когда ролей становится много (Admin, SuperAdmin, Moderator, Editor, Viewer)? Как это приводит к role explosion? Почему claims более гибкие?

120. Проанализируйте authorization policies в ASP.NET Core. Как политики позволяют выразить сложную бизнес-логику? Приведите примеры: "доступ только владельцу ресурса", "требуется 2FA", "только в рабочее время". Как тестировать такие политики?

121. Объясните реализацию кастомных authorization handlers. Когда встроенных requirement (RequireClaim, RequireRole) недостаточно? Как создать requirement типа "пользователь старше 18 лет" или "аккаунт активен больше месяца"?

122. Разберите проблему устаревших claims в JWT. Что произойдет, если роль пользователя изменилась в базе данных, но токен еще валиден? Как часто обновлять токены? Какие trade-offs между безопасностью и удобством?

123. Объясните концепцию refresh tokens в деталях. Почему access token короткоживущий (15 мин), а refresh token долгоживущий (7-30 дней)? Как это balance между безопасностью и UX? Что делать при краже refresh token?

124. Проанализируйте token rotation strategy. Почему при использовании refresh token стоит генерировать новый refresh token? Как это защищает от replay атак? Что такое refresh token families?

125. Разберите хранение refresh tokens. Где хранить на клиенте: localStorage (XSS уязвим), httpOnly cookies (CSRF уязвим)? Что лучше? Где хранить на сервере: в базе данных или Redis? Нужно ли хешировать refresh tokens?

126. Объясните сценарий отзыва токенов. Как реализовать "выйти со всех устройств"? Как работать с token blacklist или whitelist? Какие performance implications у проверки каждого токена в базе данных?

---

## Лекция 4: Работа с файлами и real-time коммуникация

### File upload/download, Streaming, Валидация файлов

127. Разберите multipart/form-data encoding. Почему для загрузки файлов нельзя использовать application/json? Как работает boundary в multipart запросах? Какой overhead у multipart encoding? Как это влияет на размер запроса?

128. Объясните работу IFormFile в ASP.NET Core. Что происходит с файлом при model binding? Где файл хранится временно: в памяти или на диске? При каком размере ASP.NET Core переключается с memory buffer на файл? Какие implications для производительности?

129. Проанализируйте проблему загрузки больших файлов. Почему нельзя загружать 1GB файл полностью в память? Что произойдет с сервером при 10 одновременных загрузках? Как streaming решает эту проблему? Что такое backpressure?

130. Разберите streaming с MultipartReader. Как читать файл по частям (chunks)? Почему нужно отключать model binding атрибутом? Как обрабатывать каждый chunk: писать сразу на диск или в blob storage? Какие ошибки могут возникнуть mid-stream?

131. Объясните валидацию файлов на нескольких уровнях. Почему нельзя доверять только расширению файла или Content-Type заголовку? Как клиент может подделать эти значения? Что такое magic bytes (file signatures) и как проверять реальный тип файла?

132. Проанализируйте security угрозы при работе с файлами. Что такое path traversal атака (`../../etc/passwd`)? Как защититься? Почему нельзя сохранять файлы с оригинальными именами? Как генерировать безопасные имена файлов (GUID, hash)?

133. Разберите проблему хранения файлов. Database vs File System vs Blob Storage - trade-offs каждого подхода. Когда хранить файлы в БД оправдано? Какие проблемы с backup, performance, scaling? Почему blob storage предпочтительнее для production?

134. Объясните антивирусное сканирование загруженных файлов. Как интегрировать antivirus API? Что делать с файлом до окончания сканирования: показывать пользователю или держать в карантине? Что делать с зараженными файлами? Какой UX для пользователя?

135. Проанализируйте download файлов и Content-Disposition header. В чем разница между `inline` и `attachment`? Как браузер решает, показать файл или скачать? Как работать с разными MIME types? Что такое range requests для возобновляемых загрузок?

### WebSockets и SignalR: real-time коммуникация

136. Объясните фундаментальное отличие WebSocket от HTTP. Почему HTTP неэффективен для real-time коммуникации? Что такое long polling и какие у него проблемы? Как WebSocket устанавливает persistent bidirectional connection?

137. Разберите WebSocket handshake процесс. Как начинается с HTTP Upgrade запроса? Какие заголовки отправляются (Upgrade, Connection, Sec-WebSocket-Key)? Что возвращает сервер (101 Switching Protocols)? Почему это HTTP-совместимо с proxies и firewalls?

138. Проанализируйте frames в WebSocket protocol. Как данные передаются через фреймы? Что такое text frames vs binary frames? Как работают ping/pong frames для keep-alive? Что такое close handshake и зачем нужен graceful shutdown?

139. Объясните проблемы масштабирования WebSocket connections. Почему тысячи открытых соединений потребляют много ресурсов? Как работать с load balancers (sticky sessions)? Что такое scale-out problem для broadcasting в кластере серверов?

140. Разберите абстракцию SignalR поверх WebSockets. Какие проблемы SignalR решает? Что такое transport negotiation и fallback (WebSockets → Server-Sent Events → Long Polling)? Как SignalR обеспечивает reconnection и automatic retry?

141. Проанализируйте концепцию Hubs в SignalR. Чем Hub отличается от обычного класса? Как работает RPC (Remote Procedure Call) через SignalR? Почему методы Hub могут вызываться с клиента? Какие ограничения на параметры методов?

142. Объясните groups в SignalR. Зачем нужна группировка connections? Как реализовать приватные чаты между пользователями? Как broadcast сообщение определенной группе? Что происходит с группами при disconnect/reconnect?

143. Разберите масштабирование SignalR с помощью backplane. Что такое SignalR backplane (Redis, Azure Service Bus)? Как синхронизировать состояние между несколькими серверами? Какие trade-offs у каждого backplane провайдера?

144. Проанализируйте авторизацию в SignalR. Как защитить Hub методы? Можно ли использовать JWT с SignalR? Как передать токен при подключении? Что делать при истечении токена для активного connection?

---

## Лекция 5: Продвинутые возможности и best practices

### Фильтры, Middleware и request pipeline

145. Сравните фильтры и middleware в ASP.NET Core. В чем фундаментальная разница их областей применения? Когда использовать фильтры (controller-specific logic), а когда middleware (application-wide concerns)? Как это влияет на архитектуру?

146. Разберите типы фильтров и pipeline их выполнения. Какой порядок: Authorization → Resource → Action → Exception → Result filters? Почему такой порядок? Что происходит при short-circuit (когда фильтр прерывает pipeline)?

147. Объясните Action Filters в деталях. Когда выполняются OnActionExecuting и OnActionExecuted? Как использовать для логирования, модификации параметров, кэширования? Приведите примеры полезных action filters (validation, transaction management).

148. Проанализируйте Exception Filters. Чем они отличаются от global exception handler middleware? Когда использовать каждый подход? Как exception filters видят context (controller, action)? Как формировать problem details ответы?

149. Разберите scope фильтров: global, controller, action level. Как Order property влияет на выполнение? Что происходит при конфликте фильтров? Как реализовать conditional фильтры (применяются только при определенных условиях)?

150. Объясните middleware pipeline как chain of responsibility pattern. Как каждый middleware вызывает next()? Что такое terminal middleware? Почему порядок middleware критичен (например, UseStaticFiles до UseRouting)?

151. Проанализируйте создание кастомных middleware. Какие два подхода: inline (Use) vs convention-based class? Как внедрять зависимости в middleware? Почему constructor injection для Singleton зависимостей, а InvokeAsync parameters для Scoped?

152. Разберите branching pipeline с Map и MapWhen. Когда нужно разветвлять pipeline на разные пути? Как создать отдельную pipeline для /api vs /admin? Какие use cases для conditional middleware?

### DTOs, AutoMapper и FluentValidation

153. Объясните проблему over-posting (mass assignment) атаки. Как возврат entities напрямую из API создает security hole? Приведите пример: клиент отправляет `{"name": "John", "isAdmin": true}`. Как DTO защищает? Почему нельзя просто игнорировать лишние поля?

154. Разберите концепцию разделения DTOs на Request и Response. Почему CreateUserDto ≠ UserResponseDto? Какие поля нужны при создании (password), а какие при чтении (id, createdAt)? Как это упрощает валидацию и документацию API?

155. Проанализируйте AutoMapper как решение проблемы boilerplate mapping кода. Какой overhead у manual mapping (`.Select()`, конструкторы)? Когда AutoMapper избыточен (простые 1-to-1 mappings)? Какие performance implications у runtime reflection?

156. Объясните configuration AutoMapper profiles. Почему mapping logic должна быть centralized? Как организовать profiles для больших проектов? Что такое ReverseMap и когда его использовать? Какие проблемы создает bidirectional mapping?

157. Разберите сложные mapping scenarios в AutoMapper. Как маппить вложенные объекты? Как использовать ForMember для custom logic? Что делать с properties разных типов? Когда лучше написать custom converter?

158. Проанализируйте недостатки Data Annotations для валидации. Почему атрибуты создают tight coupling? Как тестировать валидацию с атрибутами? Почему сложно реализовать conditional validation? Как это ограничивает переиспользование validation logic?

159. Объясните FluentValidation как более гибкую альтернативу. Как separation validators от DTOs упрощает тестирование? Как реализовать сложные правила (валидация зависит от других полей, async validation для проверки в БД)?

160. Разберите интеграцию FluentValidation с ASP.NET Core. Когда происходит валидация: до action метода или manual? Как кастомизировать error messages? Как работает с localization? Что делать при validation failures?

161. Проанализируйте performance validation. Когда валидация становится bottleneck (тысячи правил, регулярные выражения, database lookups)? Как оптимизировать? Когда лучше перенести валидацию на клиент или асинхронно?

### API versioning и асинхронное программирование

162. Объясните необходимость версионирования API. Что происходит при breaking changes без версий? Как поддерживать старых клиентов при добавлении новых features? Приведите примеры breaking vs non-breaking changes. Как долго поддерживать старые версии?

163. Сравните стратегии версионирования: URL (/v1/users), Header (api-version: 1.0), Query string (?version=1). Какие pros/cons у каждого? Почему URL versioning самый популярный? Как это влияет на SEO и caching?

164. Разберите проблему версионирования в distributed systems. Как версионировать API в микросервисах? Что такое compatibility matrix между сервисами? Как избежать version hell? Что такое semantic versioning для APIs?

165. Проанализируйте документирование версий в Swagger. Как создать отдельные Swagger documents для каждой версии? Как клиент выбирает версию в UI? Как показывать deprecated endpoints? Какие alternative strategies (единый документ с фильтрацией)?

166. Объясните фундаментальные принципы async/await. Почему это не parallelism, а concurrency? Как async освобождает thread pool threads? Что происходит с thread при await: он блокируется или возвращается в pool?

167. Разберите async/await в контексте I/O-bound операций (БД, HTTP, файлы). Почему async критичен для scalability Web API? Сколько requests может обработать синхронный vs асинхронный API? Какая связь с thread pool exhaustion?

168. Проанализируйте state machine, генерируемый компилятором для async методов. Что происходит под капотом при await? Как сохраняется состояние? Что такое continuation? Какой overhead у async (memory, CPU)?

169. Объясните anti-patterns async/await. Почему async void опасен (unhandled exceptions)? Что такое sync over async (`.Result`, `.Wait()`) и почему это deadlock? Когда допустим sync over async?

170. Разберите ConfigureAwait(false) и synchronization context. Зачем нужен в .NET Framework? Почему в ASP.NET Core ConfigureAwait(false) не нужен? Как работает SynchronizationContext? Когда его нет?

171. Проанализируйте параллелизм в async: Task.WhenAll vs Task.WhenAny. Как запустить несколько async операций одновременно? Какие performance gains? Как обрабатывать exceptions в WhenAll? Что такое Task.WaitAll vs Task.WhenAll?

### Обработка ошибок и глобальный exception handling

172. Объясните RFC 7807 Problem Details standard. Почему важна стандартизация error responses? Какие поля должны быть (type, title, status, detail, instance)? Как это помогает клиентам обрабатывать ошибки единообразно?

173. Разберите разницу между handled и unhandled exceptions. Когда выбрасывать exceptions (exceptional conditions), а когда возвращать error responses? Что такое exceptions for control flow anti-pattern? Какой performance impact у exceptions?

174. Проанализируйте стратегии глобальной обработки ошибок. Exception middleware vs Exception filters vs IExceptionHandler (.NET 8). Какие trade-offs у каждого подхода? Когда использовать комбинацию?

175. Объясните проблему информационных утечек в error messages. Почему нельзя возвращать stack traces и внутренние детали в production? Как это помогает атакующим? Как балансировать между debugging и security?

176. Разберите structured logging exceptions. Как логировать контекст (user, request path, parameters)? Что такое correlation ID и как он связывает логи? Как избежать логирования sensitive data (passwords, tokens)?

177. Проанализируйте обработку разных типов ошибок. Validation errors (400), Authorization (403), Not Found (404), Business logic errors (409 Conflict). Как определить правильный status code? Как формировать понятные error messages?

178. Объясните retry policies и transient errors. Какие ошибки можно retry (network timeout, 503 Service Unavailable)? Какие нельзя (400 Bad Request)? Что такое exponential backoff? Как Polly помогает с resilient HTTP calls?

179. Разберите circuit breaker pattern для handling cascading failures. Как защитить систему от failing dependencies? Когда открывать circuit? Что такое half-open state? Как это связано с microservices resilience?

---

## Лекция 6: Performance, безопасность и deployment

### Caching (In-Memory, Distributed, Response caching)

180. Объясните фундаментальный trade-off кэширования: freshness vs performance. Как определить, что можно кэшировать? Какие данные не стоит кэшировать (highly dynamic, user-specific)? Как измерить cache hit rate и эффективность?

181. Разберите In-Memory cache в деталях. Где данные хранятся (process memory)? Что происходит при перезапуске приложения? Как работает в load-balanced environment (каждый сервер свой кэш)? Какие проблемы это создает?

182. Проанализируйте absolute vs sliding expiration. Когда использовать каждый? Что происходит с sliding expiration при частых обращениях? Как комбинировать оба подхода? Что такое cache stampede problem при expiration?

183. Объясните необходимость Distributed cache в production. Какие проблемы с in-memory cache в кластере? Как Redis решает эту проблему? Что такое cache coherence? Какой latency overhead у distributed cache vs in-memory?

184. Разберите cache eviction policies. Что такое LRU (Least Recently Used)? Как работает memory pressure в .NET? Что происходит при нехватке памяти? Как настроить size limit для кэша?

185. Проанализируйте Response Caching. Чем отличается от data caching? Как работает с HTTP cache-control headers? Что такое ETags и conditional requests (304 Not Modified)? Где кэш хранится: client, proxy, server?

186. Объясните cache invalidation problem ("There are only two hard things in Computer Science: cache invalidation and naming things"). Как синхронизировать кэш с базой данных? Что такое write-through, write-behind caching? Когда использовать cache tags для grouped invalidation?

187. Разберите security implications caching. Можно ли кэшировать authenticated responses? Что такое cache poisoning? Как защититься от утечки данных через shared cache? Почему private vs public caching важен?

188. Проанализируйте monitoring и debugging cache. Как измерить cache effectiveness (hit rate, miss rate, latency)? Какие метрики важны? Как найти cache-related bugs (stale data, неожиданные cache hits)? Что такое cache warming?

### Rate limiting, throttling и CORS

189. Объясните необходимость rate limiting для защиты API. От каких атак защищает (DDoS, brute-force, scraping)? Как это связано с fair usage и cost control? Какие бизнес-модели используют rate limiting (freemium tiers)?

190. Сравните алгоритмы rate limiting: Fixed Window, Sliding Window, Token Bucket, Leaky Bucket. Какие проблемы у каждого? Почему Fixed Window создает burst в начале окна? Как Token Bucket более fair?

191. Разберите реализацию rate limiting в ASP.NET Core 7+. Как работают встроенные limiters? Как определить limit key (по IP, user ID, API key)? Что возвращать клиенту: 429 Too Many Requests? Какие headers (Retry-After, X-RateLimit-*)?

192. Проанализируйте distributed rate limiting. Как синхронизировать лимиты в кластере серверов? Почему in-memory недостаточно? Как Redis помогает? Что такое race conditions в distributed limiters?

193. Объясните Same-Origin Policy в браузерах. Что считается same origin (protocol + domain + port)? Почему это security feature? Какие атаки SOP предотвращает? Почему API на другом домене блокируется?

194. Разберите CORS preflight requests. Когда браузер отправляет OPTIONS запрос? Что такое simple requests vs preflighted? Какие headers и methods триггерят preflight? Какой performance impact?

195. Проанализируйте CORS headers и их значение. Access-Control-Allow-Origin (wildcard опасен), Access-Control-Allow-Credentials (нельзя с wildcard), Access-Control-Allow-Headers, Access-Control-Max-Age (кэширование preflight). Как настроить безопасно?

196. Объясните CORS в контексте security. Почему AllowAnyOrigin() опасен в production? Как это связано с CSRF атаками? Что такое credential-based attacks? Когда CORS не защищает (non-browser clients)?

197. Разберите CORS vs CSRF protection. CORS не заменяет CSRF tokens. Почему? Как атаки работают по-разному? Как комбинировать защиты для maximum security?

### Pagination, Filtering и Logging

198. Объясните проблему возврата больших коллекций из API. Что произойдет с GET /api/users для миллиона пользователей? Как это влияет на memory, bandwidth, client performance? Почему пагинация обязательна в production APIs?

199. Сравните offset-based (page/pageSize) и cursor-based пагинацию. Какие проблемы с offset при вставке/удалении данных? Почему cursor более consistent? Какие недостатки cursor (нельзя прыгнуть на страницу N)? Когда использовать каждый?

200. Разберите metadata в paginated responses. Какую информацию нужно возвращать (totalCount, totalPages, hasNextPage, hasPreviousPage)? Где размещать: в response body или headers (X-Pagination)? Как это влияет на client implementation?

201. Проанализируйте filtering и его реализацию. Как передавать фильтры: query string, request body, или GraphQL-like syntax? Что такое dynamic query building? Какие security risks (SQL injection через filters)?

202. Объясните specification pattern для сложных filtering scenarios. Как инкапсулировать query logic? Как комбинировать спецификации (And, Or, Not)? Почему это лучше, чем десятки параметров в методе?

203. Разберите sorting в API. Как передавать (sort=name,-createdAt для desc)? Как валидировать sort parameters (защита от invalid column names)? Какой performance impact у сортировки без индексов?

204. Проанализируйте structured logging концепцию. Чем отличается от обычного string logging? Как properties помогают при анализе? Что такое log sinks и как они обрабатывают structured data?

205. Объясните роль Serilog в .NET ecosystem. Почему Serilog предпочтительнее встроенного ILogger для production? Как работают enrichers (добавление context)? Что такое minimum log level filtering?

206. Разберите correlation ID для distributed tracing. Как связать логи одного request через multiple services? Где генерировать correlation ID? Как передавать между сервисами? Какие tools (Application Insights, Elastic APM) помогают с трейсингом?

207. Проанализируйте что логировать и что не логировать. Какие levels использовать (Debug для development, Information для key events, Warning для recoverable errors, Error для exceptions)? Почему нельзя логировать passwords, tokens, PII? Как замаскировать sensitive data?

### Health checks и мониторинг

208. Объясните роль health checks в production systems. Зачем нужны health endpoints? Как orchestrators (Kubernetes) используют health checks? Что такое zero-downtime deployments и роль health checks?

209. Разберите разницу между liveness и readiness probes. Когда использовать каждый? Что происходит при failing liveness (container restart)? Что при failing readiness (remove from load balancer)? Почему важно различать?

210. Проанализируйте что проверять в health checks. Database connectivity, external API availability, disk space, memory usage. Как определить критичные vs некритичные зависимости? Что делать, если Redis down, но API может работать?

211. Объясните health check statuses: Healthy, Degraded, Unhealthy. Когда возвращать каждый? Что такое degraded mode работы? Как это влияет на routing traffic? Какие HTTP status codes соответствуют (200, 200, 503)?

212. Разберите performance considerations health checks. Как часто вызывать (каждые 10 сек)? Какой timeout? Что если health check сам тяжелый (query к БД)? Как избежать, чтобы health checks сами не стали bottleneck?

213. Проанализируйте кастомные health checks. Как проверить сложные условия (доступность payment gateway, rate limit не исчерпан)? Как реализовать IHealthCheck? Как агрегировать несколько health checks?

214. Объясните мониторинг и observability в production. Чем отличается от простого logging? Что такое metrics (latency, throughput, error rate)? Какие инструменты (Prometheus, Grafana, Application Insights)?

215. Разберите golden signals monitoring (латентность, трафик, ошибки, насыщенность). Почему эти метрики критичны? Как настроить алерты? Что такое SLI, SLO, SLA? Как это влияет на incident response?

216. Проанализируйте distributed tracing в микросервисах. Как отследить request через десятки сервисов? Что такое trace, span, context propagation? Как работают инструменты типа Jaeger, Zipkin? Какой overhead у tracing?