# Лабораторная работа №3. База данных и Entity Framework Core

## Цель работы
Перевести проект с файлового хранилища на базу данных с использованием Entity Framework Core.

---

## Задание 1. Настройка Entity Framework Core

### Требования
- Установите необходимые NuGet пакеты для EF Core
- Создайте DbContext с DbSet для каждой сущности
- Настройте все модели через Fluent API в `OnModelCreating`:
  - Первичные ключи (составные для промежуточных таблиц)
  - Ограничения: IsRequired, HasMaxLength, HasPrecision, HasDefaultValueSql
  - Индексы: уникальные, обычные, составные
  - Computed columns (опционально)

### Связи
- **One-to-Many** (минимум 3-4 связи)
  - Настройте поведение при удалении (Cascade, Restrict, SetNull)
  - Optional и Required отношения
- **Many-to-Many** (минимум 1-2 связи)
  - Явная промежуточная таблица с дополнительными полями
  - Составной первичный ключ

### Seed данные
- Роли и тестовые пользователи через `HasData()`

### Итого
- Минимум **6-8 связанных таблиц**
- Все связи настроены через Fluent API

---

## Задание 2. Миграции 

### Выбор инструмента

**Вариант А: EF Core Migrations**
- Автогенерация на основе моделей
- Команды через `dotnet ef`

**Вариант Б: FluentMigrator** 
- Явное описание миграций в коде
- Больше контроля над SQL
- Независимость от ORM


### Автоматическое применение
Настройте автоматическое применение миграций при запуске приложения (только для Development).

---

## Задание 3. Работа с данными 

### Важно
**НЕ создавайте Generic Repository и Unit of Work** — это антипаттерны поверх EF Core.
- DbContext УЖЕ является Unit of Work
- DbSet<T> УЖЕ является репозиторием


### Загрузка связанных данных
- Include и ThenInclude для eager loading
- AsSplitQuery при множественных Include
- Select для проекции в DTO (предпочтительнее Include для оптимизации)

### Сложные запросы
Реализуйте минимум **5-7 специализированных методов** для каждого основного сервиса:
- Фильтрация (Where)
- Сортировка (OrderBy, ThenBy)
- Группировка (GroupBy) с агрегацией
- Агрегация (Count, Sum, Average, Min, Max)
- Пагинация (Skip, Take + метаданные)
- Поиск по специфичным полям (email, username, status и т.д.)
- Проверки существования/уникальности

### Оптимизация
- AsNoTracking для всех read-only операций
- Избегайте N+1 проблемы
- Используйте проекцию вместо полной загрузки entity там где возможно

---

## Задание 4. Т

### Понимание
DbContext уже реализует Unit of Work — `SaveChangesAsync()` атомарно сохраняет все изменения.

### Простые операции
Для большинства случаев достаточно одного SaveChanges.

### Явные транзакции
Используйте `BeginTransaction()` когда необходимо:
- Несколько вызовов SaveChanges
- Откат при ошибках бизнес-логики
- Raw SQL между операциями EF
- Уровни изоляции отличные от стандартных
- Savepoints для частичного отката 


## Частые ошибки

### ❌ НЕ ДЕЛАЙТЕ
- Generic Repository поверх EF Core
- Unit of Work поверх DbContext
- Include без AsNoTracking для read-only
- Запросы в цикле (N+1)
- Длинные транзакции
- Игнорирование миграций

### ✅ ДЕЛАЙТЕ
- AsNoTracking для чтения
- Проекция в DTO для оптимизации
- Явные транзакции только когда нужно
- Миграции для всех изменений схемы
- Тесты для критичной логики
