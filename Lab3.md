# Лабораторная работа №3. База данных и Entity Framework Core

## Цель работы
Перевести проект с файлового хранилища на полноценную базу данных с использованием Entity Framework Core, научиться работать с миграциями, настраивать связи между сущностями и реализовывать глобальную обработку ошибок.

---

## Задание 1. Миграция на Entity Framework Core

### Установка пакетов
Установите необходимые NuGet пакеты:
- `Microsoft.EntityFrameworkCore`
- `Microsoft.EntityFrameworkCore.SqlServer` (или PostgreSQL/MySQL на ваш выбор)
- `Microsoft.EntityFrameworkCore.Tools`
- `Microsoft.EntityFrameworkCore.Design`

### Создание DbContext
Создайте класс DbContext для вашего приложения со следующими требованиями:
- Наследование от `DbContext`
- Определение `DbSet<T>` для каждой сущности вашего проекта
- Переопределение метода `OnModelCreating` для конфигурации

### Настройка Fluent API
Настройте все модели через Fluent API в методе `OnModelCreating`:

**Первичные ключи:**
- Настройте первичные ключи для всех сущностей
- Для промежуточных таблиц используйте составные ключи

**Индексы:**
- Создайте уникальный индекс на Email пользователя
- Создайте составные индексы для часто используемых комбинаций полей
- Добавьте обычные индексы для полей, по которым происходит фильтрация (CreatedAt, Status и т.д.)

**Ограничения:**
- Настройте `IsRequired()` для обязательных полей
- Установите `HasMaxLength()` для строковых полей
- Настройте `HasPrecision()` для decimal полей (цены, суммы)
- Добавьте `HasDefaultValue()` или `HasDefaultValueSql()` для дат создания

**Computed columns:**
- Создайте computed column для полного имени (FirstName + LastName)
- Добавьте другие вычисляемые поля если необходимо для вашего проекта

### Настройка связей между сущностями

**One-to-Many связи:**
- Настройте связь User → Messages с каскадным удалением
- Настройте связь User → Orders с ограничением удаления (Restrict)
- Определите минимум 3-4 One-to-Many связи для вашего проекта

**Many-to-Many связи:**
- Создайте промежуточную таблицу для User ↔ Role
- Настройте составной первичный ключ
- Добавьте дополнительные поля (AssignedAt, AssignedBy и т.д.)
- Создайте минимум 1-2 Many-to-Many связи

**Optional и Required relationships:**
- Определите optional связи (nullable foreign keys)
- Определите required связи (non-nullable foreign keys)

### Структура базы данных
Создайте минимум **6-8 связанных таблиц** для вашего проекта.

### Seed Data
Добавьте начальные данные для:
- Ролей (Admin, User, Moderator и специфичные для проекта)
- Тестовых пользователей (минимум 5)
- Других справочников
- Тестовых данных для демонстрации связей

---

## Задание 2. Реализация миграций

### Создание миграций
Создайте следующие миграции:

1. **Initial Migration**
   - Первая миграция со всеми таблицами
   - Проверьте сгенерированный SQL код

2. **Seed Migration**
   - Миграция с тестовыми данными
   - Роли, пользователи, начальные данные

3. **Дополнительные миграции (минимум 2-3)**
   - Добавление нового поля в существующую таблицу
   - Добавление индекса для оптимизации
   - Добавление новой таблицы
   - Изменение ограничений

### Применение миграций
- Примените миграции к базе данных через CLI
- Проверьте правильность создания таблиц

### Автоматическое применение миграций
Реализуйте автоматическое применение миграций при запуске приложения:
- В `Program.cs` добавьте код для применения миграций
- Используйте Scope для получения DbContext
- Вызовите метод `Database.Migrate()`

### Важные моменты
- Всегда проверяйте сгенерированный SQL перед применением
- Делайте резервные копии перед миграциями на production
- Используйте транзакции для сложных миграций
- Документируйте изменения схемы БД

---

## Задание 3. Переписать репозитории на EF Core

### Базовый репозиторий
Создайте базовый класс `Repository<T>` с методами:

**Основные методы:**
- `GetAllAsync()` — получение всех записей
- `GetByIdAsync(id)` — получение по ID
- `CreateAsync(entity)` — создание
- `UpdateAsync(entity)` — обновление
- `DeleteAsync(id)` — удаление
- `ExistsAsync(id)` — проверка существования

**Расширенные методы:**
- `GetAllAsync()` с параметрами:
  - filter (Expression<Func<T, bool>>)
  - orderBy (Func<IQueryable<T>, IOrderedQueryable<T>>)
  - includeProperties (string)
- `FindAsync(predicate)` — поиск по условию
- `CountAsync(filter)` — подсчёт с фильтром

### Специализированные репозитории
Создайте специализированные репозитории для каждой сущности:

**Примеры методов для UserRepository:**
- `FindByEmailAsync(email)`
- `FindByUsernameAsync(username)`
- `ExistsByEmailAsync(email)`
- `ExistsByUsernameAsync(username)`
- `GetWithRolesAsync(id)`

**Примеры методов для MessageRepository:**
- `GetByChannelIdAsync(channelId, page, pageSize)`
- `GetUnreadAsync(userId)`
- `GetMessageWithDetailsAsync(id)` — с Include для связанных данных
- `SearchAsync(searchTerm, channelId)`

**Примеры методов для OrderRepository:**
- `GetByStatusAsync(status, page, pageSize)`
- `GetByDateRangeAsync(from, to)`
- `GetByUserIdAsync(userId, page, pageSize)`
- `GetOrderWithItemsAsync(id)`

### Include и ThenInclude
Используйте Include для загрузки связанных данных:
- Простой Include для связанных сущностей
- ThenInclude для вложенных связей
- Multiple Include для нескольких связей

### Сложные запросы
Реализуйте следующие типы запросов:

**Фильтрация (Where):**
- По одному полю
- По нескольким полям
- По диапазону дат
- По вложенным свойствам

**Сортировка:**
- OrderBy и ThenBy
- OrderByDescending
- Множественная сортировка

**Группировка (GroupBy):**
- Группировка по одному полю
- Select после группировки
- Агрегация внутри групп

**Агрегация:**
- Count — подсчёт
- Sum — сумма
- Average — среднее
- Min/Max — минимум/максимум

**Проекция (Select):**
- Проекция в DTO
- Анонимные типы для статистики
- Select для оптимизации запросов

### Оптимизация запросов

**AsNoTracking:**
- Используйте для всех read-only операций
- Для списков и детальных просмотров

**AsSplitQuery:**
- Используйте при множественных Include
- Для избежания картезианского произведения

**Пагинация:**
- Skip и Take для пагинации
- Подсчёт общего количества записей
- Возврат метаданных пагинации

**Избегание N+1 проблемы:**
- Правильное использование Include
- Eager loading вместо lazy loading
- Проверка через SQL Profiler

---

## Задание 4. Unit of Work с транзакциями

### Интерфейс IUnitOfWork
Создайте интерфейс со следующими свойствами и методами:
- Свойства для всех репозиториев (Users, Messages, Orders и т.д.)
- `SaveChangesAsync()` — сохранение изменений
- `BeginTransactionAsync()` — начало транзакции
- `CommitTransactionAsync()` — коммит транзакции
- `RollbackTransactionAsync()` — откат транзакции
- `Dispose()` — освобождение ресурсов

### Реализация UnitOfWork
Реализуйте класс `UnitOfWork`:
- Инициализация всех репозиториев в конструкторе
- Использование одного экземпляра DbContext
- Управление транзакциями через `IDbContextTransaction`

### Работа с транзакциями
Обеспечьте:
- **ACID свойства** — атомарность, консистентность, изолированность, долговечность
- **Откат при ошибках** — автоматический rollback в блоке catch
- **Правильное освобождение ресурсов** — dispose транзакций

### Использование в сервисах
Используйте UnitOfWork для:
- Операций, затрагивающих несколько таблиц
- Обеспечения консистентности данных
- Комплексных бизнес-операций

Примеры сценариев:
- Создание заказа с элементами и обновление склада
- Перевод денег между счетами
- Отправка сообщения с уведомлениями

---

## Задание 5. Глобальная обработка ошибок

### Кастомные исключения
Создайте собственные классы исключений:

**NotFoundException:**
- Выбрасывается когда сущность не найдена
- Принимает имя сущности и ключ
- HTTP Status: 404

**ValidationException:**
- Выбрасывается при ошибках валидации
- Содержит словарь ошибок (поле → сообщения)
- HTTP Status: 400

**ConflictException:**
- Выбрасывается при конфликте данных
- Примеры: дубликат email, конфликт версий
- HTTP Status: 409

**UnauthorizedException:**
- Выбрасывается при проблемах с авторизацией
- HTTP Status: 401

**ForbiddenException:**
- Выбрасывается при недостатке прав
- HTTP Status: 403

### Exception Middleware
Создайте middleware для обработки исключений:

**Функциональность:**
- Перехват всех необработанных исключений
- Логирование ошибок с контекстом
- Формирование структурированного ответа
- Различная обработка для разных типов исключений

**Формат ответа:**
Используйте Problem Details (RFC 7807):
- Status — HTTP статус код
- Title — краткое описание типа ошибки
- Detail — детальное сообщение
- Instance — путь запроса
- Type — URI типа ошибки (опционально)

**Для ValidationException:**
- ValidationProblemDetails с полем Errors
- Список ошибок для каждого поля

**Разделение по окружениям:**
- Development: полный stack trace и детали
- Production: только безопасная информация

### Регистрация в Program.cs
- Добавьте middleware в pipeline
- Разместите в начале pipeline для перехвата всех ошибок

### Логирование
При обработке исключений логируйте:
- Тип исключения
- Сообщение
- Stack trace
- Контекст запроса (метод, путь, пользователь)
- Timestamp

---

## Задание 6. Action Filters

### ValidateModelStateAttribute
Создайте фильтр для автоматической валидации ModelState:
- Проверка `ModelState.IsValid`
- Возврат ValidationProblemDetails при ошибках
- Статус код 400

### LoggingActionFilter
Создайте фильтр для логирования:

**OnActionExecuting:**
- Логируйте входящий запрос
- Метод, путь, параметры
- Пользователь (если авторизован)
- Timestamp начала

**OnActionExecuted:**
- Логируйте результат выполнения
- Статус код
- Время выполнения
- Размер ответа (опционально)

**OnResultExecuted:**
- Финальное логирование
- Общее время обработки

### Кастомные фильтры для бизнес-логики
Создайте минимум 1-2 кастомных фильтра специфичных для вашего проекта.

Примеры:
- **CheckResourceOwnershipAttribute** — проверка владения ресурсом
- **ValidateEntityExistsAttribute** — проверка существования сущности
- **AuditActionAttribute** — аудит действий пользователя
- **RateLimitAttribute** — ограничение частоты запросов

### Регистрация фильтров
Зарегистрируйте фильтры:
- Глобально в Program.cs (для всех контроллеров)
- Через атрибуты на контроллерах/action методах

---

## Задание 7. Unit-тесты (60% покрытия)

### Тесты для репозиториев
Используйте In-Memory Database для тестирования:

**Тесты CRUD операций:**
- Create — создание сущности
- GetById — получение по ID существующей и несуществующей
- GetAll — получение всех записей
- Update — обновление существующей сущности
- Delete — удаление существующей сущности

**Тесты сложных запросов:**
- Фильтрация по различным условиям
- Сортировка по разным полям
- Пагинация с корректными метаданными
- Include связанных данных

**Тесты специализированных методов:**
- FindByEmail для UserRepository
- GetByChannelId для MessageRepository
- GetByStatus для OrderRepository

**Тесты обработки ошибок:**
- Несуществующие ID
- Некорректные параметры
- Нарушение ограничений БД

### Тесты для сервисов
Используйте моки репозиториев (Moq):

**Тесты бизнес-логики:**
- Корректные сценарии
- Граничные случаи
- Некорректные входные данные

**Тесты валидации:**
- Проверка всех правил валидации
- Проверка сообщений об ошибках

**Тесты обработки ошибок:**
- Выброс правильных исключений
- Обработка исключений из репозиториев

### Тесты для валидаторов
**Тесты правил валидации:**
- NotEmpty, NotNull
- Length, MaxLength, MinLength
- EmailAddress, Matches (regex)
- Custom правила

**Тесты асинхронной валидации:**
- Проверка уникальности email
- Проверка существования связанных сущностей

### Используемые инструменты
- **xUnit** или **NUnit** — фреймворк для тестирования
- **Moq** — библиотека для мокирования
- **FluentAssertions** — для читаемых проверок
- **Microsoft.EntityFrameworkCore.InMemory** — для In-Memory БД
- **AutoFixture** — для генерации тестовых данных (опционально)

### Покрытие тестами
Обеспечьте минимум **60% code coverage**:
- Все публичные методы репозиториев
- Вся бизнес-логика в сервисах
- Все валидаторы

---
